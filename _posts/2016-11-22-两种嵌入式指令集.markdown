--- 
layout: post
title:  两种嵌入式CPU指令集
date:   2016-11-22
time:   21:52:00
tags : [ 技术相关, Mirai ,汇编+bin, Iot安全 , 嵌入式汇编 , MIPS , SuperH ]

---


### 前

虽然一直对嵌入式设备相关的东西比较关注，除了开发工具外，也在这里写过相关的文档《[记一个组建僵尸网络的样本](/2016/03/16/记一个组建僵尸网络的样本.html)》。但一直没什么动力去花时间学习相关的汇编指令。由于近两个月一直在围绕着 Mirai 做事情，顺手就从中选两门汇编语言（MIPS、SuperH）简单学习一下，扩充下知识储备。

目前市面上的智能设备中，最常见的CPU有两种，分别为 ARM 和 MIPS（或mipsel），ARM在接触移动端安全时已经接触过了，所以这回就从 MIPS 开始。至于SuperH的选择是由于之前碰到过这种CPU设备，拿来做比对学习。

搞了两篇学习笔记，也同步更新到这个博客里，方便日后查阅。

《[MIPS 学习笔记](/2016/11/20/MIPS学习笔记.html)》

《[SuperH 学习笔记](/2016/11/21/SuperH学习笔记.html)》

配合之前写过的ARM相关的学习笔记，目前这里已经涵盖了3个嵌入式CPU资料了:

《[ARM相关的学习笔记](/goto_tags.html#ARM)》

### MIPS

该指令集在ARM普及前，在芯片领域具有相当大的影响力，甚至驰名中外的“龙芯”就是基于MIPS开发设计的，所以相关资料非常多，其中还有非常多的中文资料，学习成本相对较低。

> 既然提到“龙芯”，我很想在这里插一句，“龙芯”其实从工业设计到运算性能，完全有实力站在世界前列。但它一直无法替代Intel，AMD这些CPU的根本原因在于，生态环境不如人家成熟。这就和Windows Phone系统没法抗衡Android、IOS的道理一样。你再牛逼，人家Windows系统就是不鸟你，你能怎么办。

关于MIPS指令体系的特点，大概总结了以下几点:

1. MIPS 和 mipsel 虽然拼写不同，但两者根本就是同一个东西，在汇编指令层毫无区别。在二进制层面上，每条指令对应的字节序是反过来的。感兴趣的同学可以到[这个]()工程里，下载各自的二进制文件进行比对分析。*该工程是为了学习嵌入式逆向特意创建的，把几段具有代表性的C代码交叉编译到不同的平台下，形成产品放在bin目录下，以供逆向学习时使用*

2. 另一个值得注意的情况是，在MIPS体系中，并没有见到与状态寄存器有关的鬼东西，这种状况很是少见。无论是在X86体系中，还是ARM体系中，状态寄存器都非常重要，溢出标志 / 操作数比较结果，等关键记录，都会在状态寄存器中做一个标识，而MIPS体系中竟然连个影子都没看到，它把原来需要两条指令做的事情在一条指令中完成，可以说是一种另辟蹊径的做法。

3. 在mips体系中，还会看到另外一种诡异的现象，那就是指令碎片化。这种感觉，就和Android系统的碎片化有些类似了。由于相比其他指令体系，MIPS的指令体系更为开放，任何公司都可以比较容易的拿到授权，并在其基础上添加适合自身业务的新指令。好在大部分公司都是添加新指令，而不是更改原来的指令，这一点，让我很欣慰。

### SuperH

该指令集来自岛国的日立公司。广泛应用于微型设备，指令集特点在于其每条指令只占两个字节长度，和ARM以及MIPS相比，相同功能的代码段，可以节约大约一半的存储空间。要知道，在微型设备中那可是寸土寸金，这样的优势相当明显的。

关于 SuperH 指令体系的特点，大概总结了以下几点：

1. SH代码有极强的生存能力：在SH指令系统中，从 SH-1 到 SH-4 二进制兼容，这意味着，能在 SH-1 上运行的代码拿到 SH-4 上照样能运行，这是一条带给嵌入式设备商的福利，当新片升级时， 完全不需要去考虑原始代码在新设备的兼容性。

2. 大量指令和间接取指有关。别看SH指令只有二字节（16 bits）长度，但SH体系却能够对 32 bits 的数字做运算。这依赖于SH完善的指令体系。其立即数相关指令最多只能处理8位二进制数，当有更大的计算需求时，就要通过间接寻址的方式来解决了，当然这要牺牲一部分计算性能。好在微型设备要做的事情一般也并怎么不复杂。

3. 想学习却无处着手，SuperH的缺点在于其资料严重匮乏，除芯片厂商给出的说明文档外，基本没有其他资料可用来学习，能找到的资料除了日文，就是英文，中文资料基本别想。好在，日本人非常严谨，产品资料写的那叫一个细，屁大点事都能啰里啰嗦写一页，没错我就是在夸他们呢，你没听出来么？

4. SH 是目前接触过的所有指令体系中，唯一具有延时指令机制的体系。延时指令的含义为，当指令执行到本条指令时，并会不立即产生指令效果，而是会等待下一条指令执行完毕后再产生效果。起初并不理解这么设计的意义，后来在读到《支撑处理器的技术:永无止境的追求速度的世界》这本书时，突然理解了。这是由于每条SH指令只占两个字节，在使用流水线式指令执行操作中，如果第一条指令的结果可能更改程序的执行顺序时（比如程序条转），那么第一条指令执行一半后，第二条指令已经开始进入取指阶段，当第一条指令完全执行完毕，第二条指令其实也已经执行了一半，此时如果放弃第二条指令的执行结果，无形中就浪费了CPU的时钟周期，索性不如让第二条指令完全执行完毕，再回头处理第一条指令的结果。虽然提高了CPU的时间利用率，但也把复杂的问题抛给了程序链接器。

### 结

这里算是对最近新学到的东西做了一些总结，以备日后查阅。

