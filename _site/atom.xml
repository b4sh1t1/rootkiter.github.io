<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>rootkiter</title>
<link href="http://rootkiter.com/atom.xml" rel="self"/>
<link href="http://rootkiter.com" />
<updated>2015-04-29T23:44:29+08:00</updated>
<id>http://rootkiter.rootkiter.com/</id>
<author>
<name>RootKiter</name>
<email>2559964169@qq.com</email>
</author>

<entry>
	<title>端口转发和SOCKS代理</title>
        <link href="http://rootkiter.com/2015/04/28/LCX_SOCKS.html"/>
	<updated>2015-04-28T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/28/LCX_SOCKS</id>
	<content type="html">&lt;h1&gt;起因&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&quot;http://rootkiter.com/EarthWorm/&quot; title=&quot;EarthWorm&quot;&gt;蚯蚓&lt;/a&gt;构思之初，我在网上集中搜集过socks代理的知识，发现网上的很多资料都把 &amp;quot;Socks代理&amp;quot;和&amp;quot;socket端口转发&amp;quot;混为一谈。于是我决定写这样一篇文章，来辨析一下它们之间的异同。&lt;/p&gt;

&lt;h2&gt;Socket端口转发&lt;/h2&gt;

&lt;p&gt;lcx.exe 就是一个基于 socket 套接字实现的端口转发工具，它是从 linux 下的htran 工具移植到windows平台的。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_28_22_13/2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;一条正常的socket隧道必具备两端，一侧为服务端，它会监听一个端口等待客户端连接；&lt;br&gt;
另一侧为客户端，通过传入服务端的ip和端口，才能主动连接到服务器。  &lt;/p&gt;

&lt;p&gt;而端口转发工具（lcx.exe/htran)的工作原理其实是将两条 socket 隧道对接起来，打造一条可“异步双向通讯”的转接隧道。由于合法的socket隧道有两种接口分别对应服务端和客户端，根据数学中的排列组合可计算出端口转发供具有4种工作状态，它们是：&lt;br&gt;
&lt;code&gt;
1.“客户端” 接 “客户端”&lt;br&gt;
2.“客户端” 接 “服务端”&lt;br&gt;
3.“服务端” 接 “客户端”&lt;br&gt;
4.“服务端” 接 “服务端”&lt;br&gt;
&lt;/code&gt;
又由于端口转发为“异步双向通讯”隧道，隧道转接不分先后，所以状态2和状态3 是相同的，合并之后，便分别对应了lcx的三种工作模式，如下所示：
&lt;code&gt;
1、slave    “客户端” 接 “客户端”
2、tran     “服务端” 接 “客户端”
3、listen    “服务端” 接 “服务端”
&lt;/code&gt;
于是便可理解lcx工具的三种命令参数的格式为何是以下的样子了：&lt;br&gt;
&lt;code&gt;
–listen  ConnectPort  TransmitPort&lt;br&gt;
–tran   ConnectPort  TransmitHost  TransmitPort&lt;br&gt;
–slave  ConnectHost  ConnectPort  TransmitHost  TransmitPort&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Socks代理&lt;/h2&gt;

&lt;p&gt;Socks 代理从名字中的“代理”二字就可以了解它的功能核心：那就是帮他人完成socket访问网络。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_28_22_13/2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;有过翻墙经历的同学大概知道浏览器（IE／Chrome／FireFox等）有设置socks代理的配置项，可用来访问网络的能力。当我们通过代理服务器访问一个网址时，socks服务器其实是起到了一个中间人的身份，他分别与两方（浏览器／被访问的网站）通讯然后将获取到的结果告知另一方。&lt;br&gt;
在使用代理服务的过程中我们会发现，只要配置好socks代理后，就不再需要指定被访问目标，直接在浏览器的地址栏输入地址就能访问任意网站。这是由于socks代理中有一个交互协议，当我们准备访问一个网站并敲击回车时，浏览器会先发送一个被访问目标的基本信息（URL和服务端口）给socks服务端，socks服务端解析了这个信息后，会代替浏览器去访问目标网站，并将访问结果回复给浏览器端。这便是socks代理的工作原理了。&lt;br&gt;
通过这段对socks代理的描述，可知socks代理其实可理解为一个增强版的 lcx -tran 它在服务端监听一个服务端口（ConnectPort），当有新的连接请求时会从socks协议中解析出访问目标的URL（TransmitHost）的目标端口(TransmitPort)，再开始执行lcx -tran 的具体功能。  &lt;/p&gt;

&lt;h2&gt;两者的异同&lt;/h2&gt;

&lt;p&gt;1.socket端口转发无需通讯协议支持，而socks代理需要socks协议支持。&lt;br&gt;
2.socket端口转发有三种工作方式，而socks代理仅有一种工作方式。&lt;br&gt;
3.如果说socks是帮他人访问网络（一对多），那么端口转发就是帮他人访问主机的某个端口（一对一）。&lt;/p&gt;

&lt;h1&gt;一句话总结：&lt;/h1&gt;

&lt;p&gt;这篇笔记从“socket端口转发”和 “socks代理” 两者的工作原理出发，介绍了两者的区别。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>构造ROP</title>
        <link href="http://rootkiter.com/2015/04/24/MAKE_ROP.html"/>
	<updated>2015-04-24T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/24/MAKE_ROP</id>
	<content type="html">&lt;p&gt;构造一个可用的ROP可以分7步来操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;确定目标&lt;br&gt;&lt;/li&gt;
&lt;li&gt;针对目标实现步骤，确定需要的ROP样式&lt;br&gt;&lt;/li&gt;
&lt;li&gt;搜索模块中可用代码片段。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;封装代码片段至模块&lt;br&gt;&lt;/li&gt;
&lt;li&gt;书写简单的ROP伪指令&lt;br&gt;&lt;/li&gt;
&lt;li&gt;组装代码片段&lt;br&gt;&lt;/li&gt;
&lt;li&gt;调试完成&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;一、确定目标：&lt;/h3&gt;

&lt;p&gt;无论做什么都需要有明确的目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;已知一信息泄漏漏洞（MS13-037）可泄漏 ntdll 的基地址 @ntdll_base;&lt;/li&gt;
&lt;li&gt;被攻击目标为 WIN7_x86 ＋ IE8 ，且 ntdll 版本号为 6.1.7601.17514。&lt;/li&gt;
&lt;li&gt;有一任意代码执行漏洞（任意 EIP 可控漏洞均可）&lt;/li&gt;
&lt;li&gt;求一可用的 metasploit 的漏洞利用模块。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过阅读&lt;a href=&quot;/2014/02/28/ROPIntroduce.html&quot; title=&quot;ROP介绍&quot;&gt;第一篇笔记&lt;/a&gt;可以得知：调用ZwProtectVirtualMemory（）可以完成关闭DEP的操作，而调用之前需要将栈状态布置为下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;此时通过RETN指令调用Zw*函数后才能将shellcode所在区域开DEP保护。所以我们的目标就是构造这样一片的堆栈结构。&lt;/p&gt;

&lt;h3&gt;二、针对目标实现步骤，确定需要的ROP样式&lt;/h3&gt;

&lt;p&gt;观察目标堆栈结构可以发现，构造这样的堆栈存在以下几点困难：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
1.ShellCode 地址由于是动态分配到堆内存中，无法固定&lt;br&gt;
2.0x00000040   和 0x0000 0400 两个数据存在格式为%u0000的unicode坏字符，无法直接部署。
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是，这种栈状态存在7个双字需要在ROP中动态设置(参照上图带红点的位置)。这可能会用到以下种类的ROP代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
1.MOV [ reg ], reg&lt;br&gt;
//布置堆栈，操作内存，当然需要写内存指令了&lt;br&gt;
2.ADD（SUB） reg,reg&lt;br&gt;
//计算shellcode -0c、shellcode-04这种地址的值&lt;br&gt;
//计算MOV [reg],reg 指令中  [reg] 的值&lt;br&gt;
3.MOV  reg，ESP&lt;br&gt;
//这条指令是最重要的，没有它，根本无法动态定位shellcode地址&lt;br&gt;
4.NOT reg&lt;br&gt;
//这条指令可有可没有，用来计算0x00000040 和 0x00000400 这种值，如果没有的话，通过Add（SUB） 指令也能实现&lt;br&gt;
5.POP reg&lt;br&gt;
//这条指令可用于向寄存器赋值，是寄存器计算前的必要指令。&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这些种指令中，实际查找时会发现除第五条指令外，其他格式的指令均难以寻找。我也是找了一个星期才凑全这5种指令格式。&lt;/p&gt;

&lt;h3&gt;三、搜索模块中可用代码片段&lt;/h3&gt;

&lt;p&gt;搜索过程中搜到了很多和最终构造无关但可能有奇效的指令，详情可参考&lt;a href=&quot;/2015/04/23/GOLD_IN_THE_NTDLL.html&quot; title=&quot;NTDLL空间&quot;&gt;第二篇笔记&lt;/a&gt;。&lt;br&gt;
1. MOV [ reg ], reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要 12个字节的垃圾填充。&lt;br&gt;
2. SUB reg,reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要 8个字节的垃圾填充。&lt;br&gt;
3. MOV reg,ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
无需字节填充，但需要在pushad发生前构造各相关寄存器值。&lt;br&gt;
4. NOT reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要16字节垃圾填充&lt;br&gt;
5. POP reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_7.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_8.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;四、封装代码片段至模块&lt;/h3&gt;

&lt;p&gt;为了后期使用的方便，最好能够将个代码片段封装成ROP片段，最终ROP_chain构造时直接拷贝粘贴即可。各个指令片段封装格式如下所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
MOV [ ecx ], eax&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
SUB  eax,edx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
MOV  ecx，ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
MOV  eax, ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
NOT eax&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
POP ecx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
POP edx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_8.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;五、书写简单的ROP伪指令&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_5_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;p&gt;这段ROP片段 ＋ Zw* ＋ “调用栈结构” + Shellcode，就可以成功关闭DEP并运行后侧的 shellcode 了。 
然而在这段伪指令中发现，每次写地址需要计算两次，如果都用SUB实现，将会经常备份数据，因为eax只有一个，组织代码将会相当复杂，如果能找到其他的加法指令就会好多了。
带着这个问题，我在内存中又简单的搜索了一下，顺利找到了以下代码：
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_5_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这处代码原本是INC ECX \  RETN 如果连续使用4次，正好能够完成ADD ecx，4的功能。至此“万事具备，只欠拼接”。&lt;/p&gt;

&lt;h3&gt;六、组装代码片段&lt;/h3&gt;

&lt;p&gt;这个没什么好说的了，就是参照伪代码，把封装好的代码片段组合到一起，如下图所示：
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_6_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;七、调试完成&lt;/h3&gt;

&lt;p&gt;在metasploit中启动运行，用IE8+Win7访问，查看是否能够成功执行shellcode，如果访问失败，可以通过设置c3断点，或在ROP中设置0x41414141进行中断，另外SUB指令执行时的EDX值，既可以在构造完成后集中计算，也可以单步跟踪时手动调节。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_7_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_7_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h1&gt;结尾：&lt;/h1&gt;

&lt;p&gt;本篇笔记记录了一个相对复杂的ROP构造过程。&lt;/p&gt;

&lt;p&gt;ROP构造是一个奇妙的过程，它和程序设计有着很多相似之处，都是需要先明确目标，然后选择伪代码描述，最终用代码组织完成。然而和普通程序设计不同的是，ROP的语法块需要在内存中去寻找，并自己定义，只有找全了各种功能的代码片段，才能完成最终的ROP_chain编写。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ntdll 空间中的金疙瘩</title>
        <link href="http://rootkiter.com/2015/04/23/GOLD_IN_THE_NTDLL.html"/>
	<updated>2015-04-23T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/23/GOLD_IN_THE_NTDLL</id>
	<content type="html">&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;通过阅读&lt;a href=&quot;/2014/02/28/ROPIntroduce.html&quot; title=&quot;ROP介绍&quot;&gt;第一篇笔记&lt;/a&gt;，可以知道，ROP构造是软件类漏洞利用中很重要的一环(为了绕过dep保护)，然而用过mona工具的童鞋应该都清楚，这个工具似乎不太好用。即使你通过mona搞定了ROP骨架的生成，有时仍然需要微调，特别是当mona结果中拥有和漏洞环境相关的坏字符时，修复ROP-chain 也成为了软件类漏洞利用的重要一环。&lt;/p&gt;

&lt;p&gt;此时这篇笔记的意义就出现了：&lt;strong&gt;&lt;em&gt;如何找到有用的ROP素材，并将存在问题的ROP-chain修复。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文中提到的代码素材均来自于ntdll.dll文件，其中&lt;br&gt;
&lt;code&gt;
ntdll.dll版本号为：6.1.7601.17514&lt;br&gt;
本机Win7 启动后ntdll的偏移： 0x77880000
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;声明：&lt;br&gt;
不同版本，得到的代码偏移可能不同。&lt;br&gt;
至于DLL模块基地址嘛。。。那是一定不同滴。。。因为我是在Win7环境下查找的指令，看客可以通过搜索特定指令序列，或通过我给出的偏移计算出来。&lt;br&gt;
本段将纪录，我在 ntdll.dll 中找到的各种指令，它们可以用来做四则运算，甚至用来处理内存拷贝。&lt;/p&gt;

&lt;h1&gt;有趣的代码片段&lt;/h1&gt;

&lt;h2&gt;XCHG系列&lt;/h2&gt;

&lt;p&gt;这个系列的指令，在ROP构造中有奇效。ROP-chain中每个寄存器中的值都是宝贝，遗失不得。而在执行 xchg 指令时，完全不会干扰到其他寄存器的内容，他们之间真的非常般配。&lt;/p&gt;

&lt;h3&gt;xchg eax,esp&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是 IE 漏洞利用中经常用到的一条控制ESP的指令。它在漏洞触发的那一刻能够将ESP从“栈指针”，改成“堆指针”，配合“堆喷射”技术完成漏洞利用。&lt;/p&gt;

&lt;h3&gt;xchg eax,edx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是一条可用来保存 eax 的指令。由于多数汇编指令都会用到eax寄存器，这条指令刚好能把当前寄存器中的数据同 edx 交换一下，用起来很方便。&lt;/p&gt;

&lt;h3&gt;xchg eax,ecx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;当我想把 ECX 作为内存指针时，完全可以通过 EAX 计算出相应地址，然后放到交换到ECX中。&lt;/p&gt;

&lt;h2&gt;add 系列&lt;/h2&gt;

&lt;h3&gt;sub eax,edx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;看到这里不明真相的群众一定会问，这明明是 sub指令，为毛划分到 add系列 中呢？&lt;br&gt;
这是因为 sub指令 比 add指令 有效得多，如果使用ADD指令执行 eax +0x20 的操作，得到的ROP素材应该是这样的：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EDX # RETN }&lt;br&gt;
0x00000020&lt;br&gt;
Address -&amp;gt; { ADD EAX,EDX …… }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时，这样的ROP-chain中出现了一个坏字符%u0000％u2000，这个坏字符将会非常难以去除。然而如果用 sub 指令，就可以是这样的：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EDX # RETN }&lt;br&gt;
0xffffffe0&lt;br&gt;
Address -&amp;gt; { SUB EAX,EDX …… }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;坏字符被巧妙的避开了，减去一个负数 等同于 加上一个正数，初中数学绝对不白学。&lt;/p&gt;

&lt;h3&gt;inc xxx&lt;/h3&gt;

&lt;h4&gt;inc ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令，我是找了很久才发现的。它出现的时候，我真的眼前一亮，它意味着，我可以不用EAX来做简单的加法运算了，当我仅需要给一个数字 +4 时，我只要写四次这个地址就好了。&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这可以节省我很多 备份数字的操作，更棒的地方在于 retn 指令没有参数，完全不需要垃圾字符填充。绝对是一条高效的 rop 指令素材。&lt;/p&gt;

&lt;h4&gt;inc eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个指令素材，有两种功效，当我需要向EAX写入1时，我可以使用三条指令，ROP示例如下：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { XOR EAX,EAX # INC EAX # RETN }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而当我仅需要将 EAX + 1 时，我可以使用：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { INC EAX # RETN  }
&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;inc ebx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令应该不用说了，和前面的 inc ecx 有相似之处。&lt;/p&gt;

&lt;h4&gt;inc edx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3&gt;其他运算&lt;/h3&gt;

&lt;h4&gt;xor eax,ecx&lt;/h4&gt;

&lt;p&gt;xor系列指令貌似都比较少，也都不够高效，需要填充很多垃圾字符：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;它的使用大概是这样的：&lt;br&gt;
&lt;code&gt;
Address  -&amp;gt; { XOR EAX,ECX # POP ESI # POP EBP # RETN 8  }
0x41414141   // skip 4 for pop esi&lt;br&gt;
0x41414141   // skip 4 for pop esi&lt;br&gt;
Address  -&amp;gt; { 下一条指令 }
0x41414141   //skip  4 for retn 8
0x41414141   //skip  4 for retn 8
&lt;/code&gt;  &lt;/p&gt;

&lt;p&gt;这条指令还是可以用来处理一些通常情况无法绕过的垃圾字符滴。&lt;/p&gt;

&lt;h4&gt;xor eax,edx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;使用方法参照 xor eax,ecx ,不过看起来似乎比那条指令更好用一些，垃圾字符填充也会少一些。&lt;/p&gt;

&lt;h4&gt;idiv ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是一个有趣的素材，它能计算除法，因为除法对寄存器的干扰实在太明显了，所以在ROP中用处也不会太大。但有一条就比没有强，没准会遇到什么样子的奇葩环境。&lt;/p&gt;

&lt;h4&gt;not eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_4_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令，是偶然发现的，并运用到了一次ROP构造中，非常好用，很可惜的是过于浪费空间，一句 RETN 0C 就要浪费 3个DWORD。使用方法大致如下：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EAX # RETN}
Address -&amp;gt; { NOT EAX # POP EBP # RETN 0C }
0x41414141     // skip 4  for pop ebp
Address -&amp;gt; { 下一条指令 }
0x41414141     // skip 4  for  retn0c
0x41414141     // skip 4  for  retn0c
0x41414141     // skip 4  for  retn0c
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;赋值系列指令&lt;/h2&gt;

&lt;h3&gt;POP XXX&lt;/h3&gt;

&lt;p&gt;这系列指令大概不用讲了，都清楚，当你需要执行 MOV EAX，0x43434343 时，
直接用&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EAX # RETN }
0x43434343
&lt;/code&gt;&lt;br&gt;
即可。
对应的4个寄存器的pop指令素材为：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;寄存器间传值&lt;/h3&gt;

&lt;h4&gt;mov eXX,eXX&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_1_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h4&gt;pushad&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
请， 先收起你的惊讶的表情... pushad 确实可以进行寄存器间赋值～～～
当你想动态定位shellcode位置时，可能会需要这样一条指令，MOV EAX，ESP，然而你找遍内存也可能搜索不到可用的素材，怎么办呢？这时，你就可以通过 PUSHAD RETN 来构造一条这样的指令。PUSHAD后堆栈的状态是这样的（如下图所示），此时再调用retn其实将会返回到EDI所指向的指令，如下图所示：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
那么我只要让堆栈中是下面这种结构，就可以把ESP的值赋值给EAX了：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
也就是说，调用PUSHAD前，你可以通过POP EDI、POP EBP、POP EBX、POP ECX等指令，部署各个寄存器所指向的地址，这样在调用PUSHAD RETN之后便可实现任意寄存器间的赋值了。下面是我在一次ROP构造时构造的 MOV ECX，ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这条指令很 cool 吧。
其实这条指令还可以在 PUSHAD 的 RETN 后，跳到某个API函数的地址，只要控制好各个寄存器的值，绝对能让人神清气爽！&lt;/p&gt;

&lt;h4&gt;5POP指令&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
我把这条指令放在这个位置，是想说明：5POP指令和PUSHAD可以很奇妙的组合在一起，当你在PUSHAD指令前将EBP指向 5POP，那么你就能非常快速的跳出 PUSHAD 对堆栈造成的影响，顺利回到ROP_chain的空间，5POP指令同样也可以拆分使用，甚至可以在一句话完成多个MOV操作，因为这条指令中同时有POP ECX 和POP EBX两条指令。&lt;/p&gt;

&lt;h4&gt;xchg eax，edx？&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这段指令共有4条，全部组合在一起，就是一个通过 ecx 寄存器实现XCHG EAX，EDX，而当你使用其中的三条时，指令就变成了 MOV 【EAX：EDX】，【EDX：ECX】或者用其中的两条就变成了 MOV EDX，ECX。&lt;/p&gt;

&lt;h4&gt;mov [ecx],eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这条指令可以实现向 ecx 指向的空间写入一个双字数据，功能很棒，当你无法通过常规方式（ROP的堆栈中存在坏字符）控制堆栈数据时，你同样可以通过这样一条指令完成前方堆栈数据的配置，以及API调用前堆栈的部署。&lt;/p&gt;

&lt;h4&gt;mov [edx],ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这片指令，也能起到写内存的作用，如果你有足够的闲心，再配合上 inc edx 这种指令进行内存计算，一定能把一整段shellcode写到一个可执行的内存片中。&lt;/p&gt;

&lt;h2&gt;回顾&lt;/h2&gt;

&lt;p&gt;本文介绍了ntdll中的一些有趣的指令素材，旨在扩充人们对于ROP指令素材的认识，很多人认为ROP素材能做的事情非常有限，通过这篇文章相信你就能很清楚的意识到，ROP指令也可以很艺术，其实我一直相信某些特殊组合的ROP指令素材同样也能具备“图灵完备”性质。当然了，这需要有足够的创造性能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS: 这是我两年之前写的一篇笔记，现在看这些文字，已经成为了上个世纪的东西。漏洞利用（软件类）的攻防也上升到了一个全新的阶段。现阶段软件漏洞利用让人感觉门槛更高了，DVE技术也开始要求利用者对脚本语言的JIT形态有一定了解，希望在掌握更多基础知识之后，回过头来能追上大牛们的步伐吧。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
</entry>

<entry>
	<title>关于博客</title>
        <link href="http://rootkiter.com/2015/04/06/AboutBlog.html"/>
	<updated>2015-04-06T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/06/AboutBlog</id>
	<content type="html">&lt;p&gt;距离上一篇文章已经过去了一年，这期间一直没想好如何来定位这个博客。&lt;/p&gt;

&lt;p&gt;前段时间把蚯蚓的主页弄起来，才想起是时候重新构思这个博客了。&lt;/p&gt;

&lt;p&gt;现在的我，开始决定不为了写博客而写博客，而是有选择性的写，挑有趣的东西来写，题材也不仅仅局限于技术，读过的书，追过的美剧，只要我觉得有趣，我就准备写在这里，Just For Fun，希望 linus 教主不会怪我乱用他老人家的名言。:-P &lt;/p&gt;

&lt;p&gt;为了保证质量，不准备追求更新时间。只要写了一篇就总有下一篇。&lt;/p&gt;

&lt;p&gt;看来这里将有机会，成为有史以来最不靠谱的博客了，YO-HO-HO-HO~~~。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ROP Introduce</title>
        <link href="http://rootkiter.com/2014/02/28/ROPIntroduce.html"/>
	<updated>2014-02-28T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2014/02/28/ROPIntroduce</id>
	<content type="html">&lt;h2&gt;背景介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DEP保护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DEP 保护是缓冲区溢出攻击出现后，出现的一种防护机制，
它的核心思想就是将内存分块后，设置不同的保护标志，
令表示代码的区块拥有执行权限，而保存数据的区块仅有
读写权限，进而控制数据区域内的shellcode无法执行。&lt;/p&gt;

&lt;p&gt;下面的两幅图分别表示了数据区域内“不可执行”和“
可执行”的状态：
&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-1.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-2.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;DEP的实现分为两种，一种为软件实现，是由各个操作系统
编译过程中引入的，在微软中叫SafeSEH。 另一种为硬件
实现，由 英特尔这种CPU硬件生产厂商固化到硬件中的，
也称作NX保护机制。&lt;/p&gt;

&lt;p&gt;单从DEP的定义可以发现，这种机制应该是能够有效抑制数据
区域内shellcode执行的。此时攻击者的面前出现了一座难以
逾越的山。&lt;/p&gt;

&lt;p&gt;要想知道如何绕过这种保护机制，请详细阅读本文下面的部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ret-to-lib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DEP 保护机制出现后，攻击者几乎无法令数据段中的shellcode
直接执行，看起来“防御技术”此时占得了先机。&lt;/p&gt;

&lt;p&gt;这里插一句题外话：我觉得 Hacker 永远是这个世界上
最聪明的一群人，它们总能发现一些常人无法发现的东西。&lt;/p&gt;

&lt;p&gt;Hacker中此时出现了一位天才，他开始教育大家，既然数据区
域没有执行状态那我们就让他们只保存数据吧，反正地址也是
数据的一部分，而内存中有还有无尽的代码供我们使用，只要
我们能把某些有趣的代码片段按照一定思路拼接起来，那么数
据区域是否可执行完全和漏洞利用就完全没有关系了。&lt;/p&gt;

&lt;p&gt;下面我将开始详细阐述这位“天才 Hacker” 的“天才想法”：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;一方面&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;汇编语言中有一系列非常有用的指令，我管它们叫做“RETN系列指
令”，这些指令的原始功能是当函数调用完成时，回退到上一层调
用函数，并继续下面的执行，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-3.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另一方面&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这种DEP的保护机制，虽然安全，却令操作系统在做某些操作时受到限制，所以操作系统中又提供了一些解除DEP保护的API供软件开发人员调用，当攻击者在内存中定位到这些API并调用时，DEP保护便失去作用了。这些API一直散落于内存的某些角落，当攻击者触发它们时，就好像触发了某个密室的暗门一样，豁然开朗。&lt;/p&gt;

&lt;p&gt;当RETN指令同这些API联系在一起时，就会产生一些奇妙的化学反应，首先看一下原本缓冲区溢出的攻击模式：&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-4.png&quot; title=&quot;ropimage/ROP1-4.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;有了DEP后的间接利用攻击的示意图：
&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-5.png&quot; title=&quot;ropimage/ROP1-5.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以看到在第二种模式下，EIP的控制是通过栈中的地址，以及代码中的RETN指令共同控制的，此时栈中的数据仍然是“数据”，而执行位置却转移到了内存的代码空间，如此下来便巧妙的绕过了DEP保护。&lt;/p&gt;

&lt;p&gt;那么这种绕过技术其实是基于一个特定条件的，那就是你到某个地址一定能找到对应的包含RETN的代码片段，可以说这是当前漏洞利用方式的薄弱环节。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASLR保护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过前面的阅读，大家可能已经了解，DEP机制的弱点就是可以通过某些API调用进行关闭，进而令其失效，然而令Hacker叫绝的是，这些API的地址完全固定，只要控制好栈结构，依然可以令shellcode得到执行。于是安全人员又提出了“ASLR机制”辅助DEP，提升系统安全性。&lt;/p&gt;

&lt;p&gt;ASLR是一种内存地址随机化技术，它的核心思路是让程序执行时所调用的外部模块地址完全随机化，这种随机化令关闭DEP保护的API也随着飘忽不定，在WIN7中它的存在并不明显，而在WIN8中该技术得到了长足的发展。&lt;/p&gt;

&lt;p&gt;WIN7中的实现是每次系统启动，模块地址随机，而启动完成后，到关闭之前，这个地址一般都不会改变。然而WIN8中，每两次程序运行，加载的模块地址都会随机起来。这种随机地址带来的安全效果非常明显，攻击者几乎没有办法利用原有攻击手段完成漏洞利用（地址随机导致无法找到关闭DEP的地址，而无法关闭DEP就无法令数据块中的shellcode得到执行），所以安全人员经常戏称“ASLR+DEP”为“海尔兄弟”，下面是WIN7中启用ASLR后，ntdll在两次电脑开启时的地址：&lt;/p&gt;

&lt;p&gt;可以看到这次电脑启动 ntdll.dll模块的位置为 0x77880000
&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-6.png&quot; aglin=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;重启计算机后，这个模块的基地址变为0x77620000&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;从以上两幅截图可以看出，地址随机化带来的直观效果就是模块顺序同样发生了改变，这就如同把攻击者放到了一个内存密室中，暗门的位置随时在变化，攻击者想要找到暗门的难度无疑增大了许多。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ASLR机制出现之后，攻击者面临着另一个严俊的挑战（我想管这个挑战叫：太行山），“ASLR”也成了他们攻击技术提升的障碍，然而所谓“道高一尺，魔高一丈”，“防御技术”总是落后于“攻击技术”出现的。&lt;/p&gt;

&lt;p&gt;对于攻击者来说“关闭DEP的API”在某个模块中的偏移地址是固定的，所以内存漏洞利用的第一步就是找到模块基地址，随后根据偏移位置找到关闭DEP的API，而“信息泄露”类漏洞能够非常出色的完成这个基址定位的功能，所以可以看到WIN7之后很多漏洞的利用都是两个漏洞组合使用的（通过信息泄露类漏洞寻找dll文件基地址，随后计算API地址，最后在代码执行类漏洞中调用API完成“关闭DEP”的操作，关闭后跳转回shellcode进行实际攻击）。 以上这种攻击思路的前半段就是“现在人们传唱的ROP”了。.&lt;/p&gt;

&lt;p&gt;下面是metasploit中某个利用模块的ROP片段截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;关于以上图片的更多技术细节，请阅读本文下面的部分获得。&lt;/p&gt;

&lt;h2&gt;ROP构造方法&lt;/h2&gt;

&lt;p&gt;通过阅读相关文章，可以得知：在Windows中有多种绕过DEP的方式，可供ROP开发，包括但不限于以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Zw(Nt)SetInformationProcess()&lt;/li&gt;
&lt;li&gt;VirtualProtect()&lt;/li&gt;
&lt;li&gt;VirtualAlloc()&lt;/li&gt;
&lt;li&gt;Zw(Nt)ProtectVirtualMemory()&lt;/li&gt;
&lt;li&gt;利用可写可执行的内存空间绕过DEP&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中1、2、3、5四种绕过办法在《0Day安全（第二版）》中有详细的阐述，其中第一种在《Python灰帽子》中，还详细介绍了如何通过脚本快速实现ROP开发。那些文字都是出自真正的大牛之手,所以我就不多说了，本节将对第四种绕过方式做一定的阐述。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Zw(Nt)ProtectVirtualMemory()函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个函数位于ntdll模块中，有两个版本，分别是Zw* 和 Nt* ，分别对应用户态和内核态的调用实现，我个人觉得两者应该没有区别，不过鉴于当前各种EXP都是通过Zw&lt;em&gt;进行利用，我们也就没必要细究Nt&lt;/em&gt; 是否能够达到利用目的了，毕竟两者的构造环境完全相同，花费的精力也完全相同。&lt;/p&gt;

&lt;p&gt;在ROP章节的末尾我给出了一个ZwProtectVirtualMemory（）ROP的构造截图，图中的代码位于metasploit的MS13_037模块中，本意是借助HeapSpray（风水）技术控制内存，进行利用的，所以在实现过程中shellcode以及参数地址可以完全固定，为了分析的方便，我们直接观察触发后堆栈状态即可。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出以下3点：&lt;/p&gt;

&lt;p&gt;1.EIP目前指向的地址正好为 [ESP-4] 对应的地址0x778896c9，可以表明此时EIP正在受ESP控制阶段。且当前指令如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2.所指向的栈内的结构和1.4节给出的截图完全相同，为了方便观察，我将栈内的结构转换一下，方便大家对比：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;3.0x0c0c0c14是常见的HeapSpray（风水）技术的遗留结果，既HeapSpray发生之前，那个位置为ROP，那个位置为shellcode是完全可控的，此处无需考虑ASLR造成的影响。&lt;/p&gt;

&lt;p&gt;通过阅读ntdll_rop 中的注释可以确定栈内各数据的含义，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-12.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;把这张图用自然语言描述出来就是：在当前进程（ProcessHandler= -1）划分0x400大小的内存片段，起始地址为0x0c0c0c40，将这块内存的状态设置为0x000040，原始状态为0x41414141（这就是垃圾字符嘛，请无视），操作完成后跳转到0x0c0c0c40继续执行（1、指向ShellCode）。&lt;/p&gt;

&lt;p&gt;相信到达这里就能清楚这条ROP的实际效果了，将shellcode所在的内存区域设置为0x00000040，当我们执行完这条指令后，这段内存会变成如下图所示的状态：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-13.png&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用mona辅助构造ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前网络中流通的ROP大部分都出自mona这个脚本，他是Immunity Sec公司开发的一个python脚本，可以辅助安全人员完成ROP的开发，原脚本仅适用于Immunity Debugger，后期开发了适用Windbg调试器的环境，看官可以参照{&lt;a herf=&quot;http://redmine.corelan.be/projects/windbglib&quot;&gt;网址&lt;/a&gt;}进行配置。此处不浪费笔墨。&lt;/p&gt;

&lt;p&gt;通过[ .load pykd.pyd ] [ !py mona rop -m ntdll.dll ]两个命令，可以实现，指定模块的ROP生成，生成时间较长，本次针对ntdll模块的ROP生成共用了近4分钟（没办法，它是虚拟了一个执行环境，然后又由Windbg调用，脚本环境下虚拟执行脚本，能快就怪了），刚开始用时候若不是我去了一趟厕所，我还以为它死掉了呢：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;生成结果的一个片段如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;Mona 一般会生成两段ROP，分别用3种格式展示：Ruby、Python、Javascript。似乎Mona生成的ROP都是针对VirtualProtect的，而且是从内存序列中提取该函数指针，所以在ASLR模式下并不完全适用，我推荐这个工具的原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它可以给你提供几个有效的ROP指令片段，以免你自己去找。&lt;/li&gt;
&lt;li&gt;它可以给你一个构造ROP的思路，当然目前来看这个思路也极不靠谱。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;有个黑阔展示过一个ROP生成工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我听过一个不负责任的传说，为了大家不找我或者谣言散播者打击报复，我就必须声明：该传闻极不负责任，请大家不要相信。&lt;/p&gt;

&lt;p&gt;这个传说是这样的：有个黑阔在BlackHat上演讲，自己历时2年，开发了一个工具，并吹嘘自己的工具可以找到很多其他工具无法挖掘到的ROP指令，然后又现场展示了一下ROP生成效果，据说效果良好- -！。并在演讲的最后宣布：该工具，闭源不放。馋死他人！！&lt;/p&gt;

&lt;h2&gt;回顾&lt;/h2&gt;

&lt;p&gt;本文起初回顾了一下ROP技术的前世今生，力求各位对二进制漏洞有兴趣的
人能够读懂。&lt;/p&gt;

&lt;p&gt;第二部分介绍了一种ROP指令的技术细节，以及生成方法。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>第一篇 博客</title>
        <link href="http://rootkiter.com/2014/02/25/firstBlogTest.html"/>
	<updated>2014-02-25T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2014/02/25/firstBlogTest</id>
	<content type="html">&lt;p&gt;&lt;em&gt;这里是普通的斜体字&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;这里可以使用 H2 的字体&lt;/h2&gt;

&lt;p&gt;这是本博客的第一篇正文，
用于检测当前的工作状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这是列表项1&lt;/li&gt; 
&lt;li&gt;这是列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;1*1&lt;/th&gt;
&lt;th&gt; =1&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;2*2&lt;/th&gt;
&lt;th&gt; =4&lt;/th&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.github.io/image/test.jpg&quot; title=&quot;图片测试&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tuhaihe.com&quot;&gt;tuhaihe.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>

</feed>
