<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>rootkiter</title>
<link href="http://rootkiter.com/atom.xml" rel="self"/>
<link href="http://rootkiter.com" />
<updated>2015-08-30T00:44:52+08:00</updated>
<id>http://rootkiter.rootkiter.com/</id>
<author>
<name>RootKiter</name>
<email>2559964169@qq.com</email>
</author>

<entry>
	<title>OpenSSL中的CA周边（三）</title>
        <link href="http://rootkiter.com/2015/08/29/OpenSSL%E4%B8%AD%E7%9A%84CA%E5%91%A8%E8%BE%B9.html"/>
	<updated>2015-08-29T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/08/29/OpenSSL中的CA周边</id>
	<content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在读OpenSSL的命令参数，在这个学习过程中发现OpenSSL之中，架构了一个非常庞大的理论系统，结果原以为学习一两天就能学完的基础知识，整整学了两个星期，才学到一些皮毛。&lt;/p&gt;

&lt;p&gt;之前整理了一些OpenSSL相关的学习笔记，这篇将涉及一些OpenSSL中和CA有关的知识。  &lt;/p&gt;

&lt;h2&gt;架设CA服务器&lt;/h2&gt;

&lt;p&gt;OpenSSL提供了CA指令用于CA服务器的模拟，这个模拟环境能够可以模拟证书的签发吊销等常见CA的操作。CA服务器的目录结构相对复杂，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/1.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;为便于测试人员使用，OpenSSL提供了一个perl脚本（/usr/lib/ssl/misc/CA.pl），以便自动生成CA的环境目录，命令序列如下所示：&lt;br&gt;
&lt;cmd&gt;
$ mkdir CA/ &amp;amp;&amp;amp; cd CA/&lt;br&gt;
$ cp /usr/lib/ssl/misc/CA.pl ./&lt;br&gt;
$ ./CA.pl -newca&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;命令执行后，环境中会自动生成一个自签名的CA根证书(demoCA/cacert.pem)，以及对应的私钥文件(demoCA/private/cakey.pem)。&lt;br&gt;
可以使用x509和rsa 两个指令查看相应文件的内容。指令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl x509 -in demoCA/cacert.pem -text -noout&lt;br&gt;
$ openssl rsa -in demoCA/private/cakey.pem -passin pass:12345678 -text –noout&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;相关字段的具体含义请参考《&lt;a href=&quot;http://rootkiter.com/2015/08/25/%E4%BB%8E%E7%99%BE%E5%BA%A6%E8%AF%81%E4%B9%A6%E5%BC%80%E5%A7%8B.html&quot;&gt;从百度证书开始&lt;/a&gt;》和《&lt;a href=&quot;http://rootkiter.com/2015/08/27/OpenSSL%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95.html&quot;&gt;OpenSSL中的非对称算法&lt;/a&gt;》两篇学习笔记中的介绍。&lt;/p&gt;

&lt;h2&gt;生成证书请求&lt;/h2&gt;

&lt;p&gt;CA签发证书前，要对客户的证书请求进行验证（除了对文件的内容进行验证以外，更多的其实是申请流程的认证，提交各种不同种类的证明材料），当验证无误后才会进行证书的颁发。所以证书请求一般由客户方提出，下面分别介绍下不同种类的证书请求生成方法.&lt;/p&gt;

&lt;h3&gt;生成RSA证书请求&lt;/h3&gt;

&lt;h4&gt;直接生成&lt;/h4&gt;

&lt;p&gt;在创建rsa密钥的同时生成证书请求，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -new -newkey rsa:1024 -keyout privkey.pem -passout pass:12345678 -out req.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;查看证书请求中的内容，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -in req.pem -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/2.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;可以看到证书请求文件中包含公钥以及证书所属者的字段，下方的Signature Algorithm字段为自己的私钥的签名值，可确保证书请求的真实性。&lt;/p&gt;

&lt;h4&gt;从RSA密钥生成&lt;/h4&gt;

&lt;p&gt;有些时候客户手中已经握有密钥，且希望从已有的密钥生成证书请求。指令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -new -key rsaprivkey.pem -out req.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;在openssl的交互提示下录入必要的申请者信息即可。此时生成的请求文件同直接生成的请求结构大体相同，如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -in req.pem -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/3.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h3&gt;生成DSA证书请求&lt;/h3&gt;

&lt;h4&gt;直接生成&lt;/h4&gt;

&lt;p&gt;由于dsa密钥的生成需要有一个dsa参数文件， dsa参数文件的生成可以使用以下命令：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsaparam -out dsaparam.pem 1024
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;在创建dsa密钥的同时生成证书请求，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -new -newkey dsa:dsaparam.pem -keyout dsakey.pem -out req.pem -passout pass:12345678
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;查看证书请求中的内容，指令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -in req.pem -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;DSA的证书请求看起来似乎复杂一些，但多出来的内容也只是dsa公钥的相关参数，所以单从请求结构上看还是相同的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/4.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h4&gt;从DSA密钥生成&lt;/h4&gt;

&lt;p&gt;有些时候客户手中已经握有密钥，且希望从已有的密钥生成证书请求。指令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -new -key dsa512_1.key -out req.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;在openssl的交互提示下录入必要的申请者信息即可。此时生成的请求文件同直接生成的请求结构大体相同，如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl req -in req.pem -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/5.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h2&gt;CA操作&lt;/h2&gt;

&lt;h3&gt;签发一个证书&lt;/h3&gt;

&lt;p&gt;CA收到证书请求后，会对客户提供的各种证明资料进行审核，审核通过后会进行证书颁发工作，证书的颁发指令格式如下所示：&lt;br&gt;
&lt;cmd&gt;
rootkiter@PC:~/CA$ openssl ca -in ~/RSA/req.pem -out ~/RSA/cert.cer -notext
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;此时，cert.cer就是颁发完成的证书了。可以通过x509指令进行内容查看，指令如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/6.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h3&gt;批量签署证书请求&lt;/h3&gt;

&lt;p&gt;在“生成证书请求”的章节，已经生成了多个种类的证书，可以将这些证书放到一个目录下，进行批量签署，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/7.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;批量签署命令格式如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl ca -notext -infiles ~/reqs_file/careq_dsa_req.pem ~/reqs_file/careq_rsa_req.pem ~/reqs_file/dsa_req.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;h3&gt;查看CA签署过的证书&lt;/h3&gt;

&lt;p&gt;demoCA目录下有个index文件，该文件记录着该CA签署过的证书内容，可以通过cat指令查看，如下所示：&lt;br&gt;
&lt;cmd&gt;
$ cat demoCA/index.txt
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/8.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;其中第三列为证书的序列号内容，在ca指令的 status选项下，可以通过指定这个序列号，来查看这个证书当前的状态，指令如下所示：&lt;br&gt;
&lt;cmd&gt;
rootkiter@PC:~/CA$ openssl ca -status FE2B37D676F58905
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/9.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h3&gt;证书吊销&lt;/h3&gt;

&lt;p&gt;当客户的密钥出现问题后（被窃取或者丢失），需要进行证书吊销，吊销指令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl ca -revoke ~/RSA/cert.cer -crl_reason keyCompromise
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;吊销后在查看该证书，可以发现其已经吊销成功，如下图所示：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/10.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h3&gt;生成吊销列表&lt;/h3&gt;

&lt;p&gt;为了方便公众查询证书的吊销状态，ca指令提供了生成吊销列表的指令，格式如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl ca -gencrl -crldays 7 -crlhours 7 -out crl.crl
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;可以通过 crl指令查看吊销列表内容，指令格式如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl ca -crl -in crl.crl -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_30_00_02/11.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h2&gt;证书验签&lt;/h2&gt;

&lt;p&gt;证书验签方法可以参考《&lt;a href=&quot;http://rootkiter.com/2015/08/25/%E4%BB%8E%E7%99%BE%E5%BA%A6%E8%AF%81%E4%B9%A6%E5%BC%80%E5%A7%8B.html&quot;&gt;从百度证书开始&lt;/a&gt;》笔记中的相关内容。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇学习笔记记录了OpenSSL中和CA相关的一些操作指令，以及背景知识。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>OpenSSL中的非对称算法（二）</title>
        <link href="http://rootkiter.com/2015/08/27/OpenSSL%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95.html"/>
	<updated>2015-08-27T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/08/27/OpenSSL中的非对称算法</id>
	<content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在读OpenSSL的命令参数，在这个学习过程中发现OpenSSL之中，架构了一个非常庞大的理论系统，结果原以为学习一两天就能学完的基础知识，整整学了两个星期，才学到一些皮毛。&lt;/p&gt;

&lt;p&gt;之前整理了一篇证书相关的学习笔记，这篇将涉及一些OpenSSL同非对称算法（RSA、DH、DSA）之间的知识。  &lt;/p&gt;

&lt;h2&gt;非对称加密算法模型&lt;/h2&gt;

&lt;h3&gt;概述&lt;/h3&gt;

&lt;p&gt;非对称算法广泛应用于数字签名和密钥协商的场景下。相比普通加密算法，非对称加密算法更侧重公开性（密钥公开，算法实现公开），这个特性是由现实生活中常见的攻击手法决定的（暴力猜解，逆向分析算法实现），可以发现它解决这种问题的思路很有趣：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“你是对我感兴趣么，那我就直接就告诉你喽。”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;通常情况下呢，面对这种毫无趣味的人，你都会觉得这玩意真没意思，然后就不去尝试了，它就安全了。:-)&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;非对称加密算法一般会有两个密钥，一个为公钥（pub_key），另一个为私钥（priv_key）,两个密钥内容各不相同，其中公钥可以对众公开，而私钥不公开。同时攻击者很难通过公钥以及加解密算法反向推出私钥。事实上，加密算法E(x)同解密算法D(x) 的实现一般也不太相同。&lt;/p&gt;

&lt;h3&gt;常见算法&lt;/h3&gt;

&lt;p&gt;非对称加密算法在“密钥协商”场景下，有两种情况，一种是“密钥磋商”；另一种是“密钥交换”，在密钥交换时公钥总是用于加密数据，而私钥总是用于解密数据。而在 “数字签名”场景下，操作过程又正好相反，即“公钥用于解密（验签），而私钥用于加密（签名）”。正是这些不同，产生了下表：&lt;/p&gt;

&lt;table class=&quot;gridtable&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;OpenSSL提供的算法
        &lt;/td&gt;
        &lt;td&gt;可用于“密钥协商” 
        &lt;/td&gt;
        &lt;td&gt;可用于“数字签名”
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;DSA
        &lt;/td&gt;
        &lt;td&gt;--
        &lt;/td&gt;
        &lt;td&gt;可以
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;DH
        &lt;/td&gt;
        &lt;td&gt;可以
        &lt;/td&gt;
        &lt;td&gt;--
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;RSA
        &lt;/td&gt;
        &lt;td&gt;可以
        &lt;/td&gt;
        &lt;td&gt;可以
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;看完这个表格，我觉得RSA算法真是完胜，有种男女通吃的赶脚。&lt;/p&gt;

&lt;h3&gt;常见的应用场景&lt;/h3&gt;

&lt;h4&gt;数字签名&lt;/h4&gt;

&lt;p&gt;个人曾经一直觉得，“数字签名”这个名词听起来很有文艺范，它要解决的问题又很不好理解，所以一直觉得那是个特神奇的领域，绝对是“高端大气上档次”。后来发现，这玩意想要解决的，竟然是一个显而易见的哲学问题：“请快速证明，我就是我自己”。    &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/1.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;为了更好的，理解这个哲学问题，我决定先编一个故事。   &lt;/p&gt;

&lt;p&gt;你在网上认识一个网友D，你俩聊得特Happy，但相互没见过面。有一天，有个人敲你家房门，他告诉你：他是D，他想给你个惊喜，来看看你。结果呢，你这家伙生性多疑，完全不信这话，非要核对一下身份，怎么办呢，此时你要做的事情就是证明眼前的这家伙就是D。与此同时他面临的问题就开始哲学起来了：“请快速证明，我就是我自己。”&lt;/p&gt;

&lt;p&gt;其实按理来说这个问题并不太难，你俩只要回忆一下你们之间聊过的独特的话就可以了。&lt;/p&gt;

&lt;p&gt;但有些时候问题确实很麻烦，比如你们俩的聊天内容总会被第三方读到（比如你家里的间谍“路由器先生”，或者他家里的间谍“交换机先生”，甚至你们聊天的会话也可能会被黑客放置了“窃听器”），这时候你们聊过的内容就不再只有你们两个知道，发现了没，哲学问题从“普通模式”转眼就变成“地狱模式”啦。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;到了这里你可能很快就想到，我有身份证啊，有了身份证，我就能证明这个哲学问题了。恭喜你，你已经打通了任督二脉，没错的，身份证是每个人身份的标识，但是互联网中没有实体身份证，能有的只是一堆数字或者字符。当某一段数字或者字符具有了“身份证”属性后它就成了“数字签名”。  &lt;/p&gt;

&lt;p&gt;“数字签名”一般由“CA机构（相当于公安局的户籍管理部门）”签发，网络中每个人都只相信CA说的话，当然了CA机构自己也需要被认定。它的签名是由它自己签发的（自签名）。&lt;/p&gt;

&lt;h4&gt;密钥约定&lt;/h4&gt;

&lt;p&gt;咱们继续数字签名章节的“哲学问题”往下聊。你和朋友D那天特别开心，然后他回家了。你们还是每天在网上聊天打发时间，但是突然有一天，聊天室服务器被黑客H入侵了，他这人不坏，就是对每个人的聊天记录感兴趣（好吧，我承认，他是个喜欢偷听他人聊天的变态）。&lt;/p&gt;

&lt;p&gt;虽然你和D的谈话被人看见也没什么（别以为我会相信），但知道有人偷窥这个事之后，心里也总觉得怪怪的。你开始思考是不是把聊天记录做个加密，以免黑客H看到。你朋友D想了想这个提议，同意了，并且夸你聪明。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;事情进展的顺利，加密算法也选好了，用上了当前性价比很高的3DES加密算法。最后的问题就是约定密钥了，这时你发现问题了，怎么把密钥告诉D而不告诉H呢，要时刻记得H是个变态，他一直研究你们的聊天记录呢。&lt;/p&gt;

&lt;p&gt;一旦你在聊天中说出了密钥的内容，他马上就会知道，于是你们只好通过其他途径共享密钥，为了避免黑客H猜解出密码继续翻阅你们的聊天记录，你们每次开始聊天都会进行“共享密钥”的操作，如果每次交换都单独找其他通讯渠道，过于繁琐，也不易操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/4.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;于是一大帮数学家想了两种靠谱的思路来解决“密钥约定”的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路1（密钥交换）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先假设我们要传输的密钥为  HELLO  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先用D的公钥D_pub_key 将密钥（HELLO）进行加密，得到密文（OLLEH）。&lt;/li&gt;
&lt;li&gt;将密文（OLLEH）通过开放会话传送给D。&lt;/li&gt;
&lt;li&gt;D拿到密文（OLLEH）后，使用自己的私钥D_priv_key进行解密还原出密钥明文（HELLO）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/5.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;此刻密钥约定成功，即使黑客H看到了密文（OLLEH）也没关系，他没有D的私钥，自然无法解出明文的密钥。
于是你们终于可以放心的用3DES加密算法聊天了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路2（密钥磋商）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个思路的精髓在于“磋商”，过程类似于买东西时候 “砍价”。具体过程描述如下：  &lt;/p&gt;

&lt;p&gt;首先呢，通讯双方各想一个密钥（两侧的密钥分别为K1、K2）记在心里，随后各自将这个密钥做一次变形（假设变形方法为E1）成为一个密钥参数(两人生成的参数分别为Z1、Z2)，并把它通知对方，此时双方都能够拿到对方的密钥参数Z，用自己刚才想到的密钥K再做一次变形（假设处理方法为E2）作为最终密钥（K3）。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/6.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;由于K3的确定过程中既有K1参与又有K2参与，所以只要算法E1和E2选择得当，双方是能够可以得到相同K3结果的。&lt;br&gt;
在这个密钥约定过程中，黑客H能得到的只有通讯双方相互发送的密钥参数Z，在攻击者不知道任何一方初始密钥（K1和K2）情况下，便无法得到最终密钥K3。&lt;br&gt;
于是，双方同样可以进行3DES的加密通讯了。  &lt;/p&gt;

&lt;h2&gt;密钥生成&lt;/h2&gt;

&lt;p&gt;个人一直觉得说是“密钥生成”，这个说法一直不够完美，不完美的原因有二：  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;得到的密钥文件一般都是公私钥一体的文件，也就是说公私钥是成对出现在相同文件中的。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;在DH算法结果中，其实只存在密钥参数而无密钥存在，其结果密钥是双方在API调用中，通过代码实现计算出来的。&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但不管哪种情况，还是先来看看这几种非对称加密算法相关的指令格式吧。&lt;/p&gt;

&lt;h3&gt;生成DSA密钥&lt;/h3&gt;

&lt;p&gt;DSA密钥生成相对复杂，一般分两步，首先要生成一个密钥参数文件，生成指令如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsaparam -out dsa512.pem 512
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;此时dsa512.pem 文件中就存储了一组dsa密钥参数，想要查看其内容，可以使用-text选项，指令格式及执行结果如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsaparam -in dsa512.pem -text –noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/7.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;这表明密钥参数中包含了3个参数的值，分别为P、Q、G，至于这三个值具体有什么作用，是DSA算法的内容，不在本文讨论范围，只要知道它们是DSA密钥参数就足够了。  &lt;/p&gt;

&lt;h4&gt;生成DSA密钥&lt;/h4&gt;

&lt;p&gt;有了DSA密钥参数后，即可根据参数生成DSA密钥了。指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl gendsa -out dsa512_1.key dsa512.pem
&lt;/cmd&gt;&lt;br&gt;
此时生成了一个名为 dsa512_1.key 的文件，OpenSSL同样提供了查看该文件内容的指令，指令格式及执行结果如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsa -in dsa512_1.key -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/8.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;可以看到，新生成的密钥文件比之前的密钥参数文件多了两个字段，分别为priv字段和pub字段，它们分别代表这DSA私钥和公钥的主体。&lt;/p&gt;

&lt;p&gt;细心的读者应该发现这个密钥的文件名为dsa512_1.key这么起名，有什么意义呢，下面我们再执行一遍生成密钥的操作，来生成一个dsa512_2.key这个文件，然后比对一下它和dsa512_1.key的区别:&lt;br&gt;
&lt;cmd&gt;
$ openssl gendsa -out dsa512_2.key dsa512.pem
$ openssl dsa -in dsa512_2.key -text -noout
&lt;/cmd&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/9.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;看出dsa512_1.key 和 dsa512_2.key 这两个文件的不同点了么，他们在使用了完全相同的命令和密钥参数后，却得到了完全不同的密钥对（仔细比对priv和pub的字段结果）。&lt;/p&gt;

&lt;p&gt;不是你眼花了，也不是gendsa指令出错了，而是DSA密钥在生成过程中，会引入一个随机数作为输入，在未指定随机数时，指令会随便找一个随机数拿过来用，这就导致了每次得到的密钥对各不相同。&lt;/p&gt;

&lt;p&gt;这个随机数也可以通过制定rand种子来设置，指令格式如下（不过经测试发现，即使制定了输入的随机数种子，生成的密钥仍然各不相同）：&lt;br&gt;
&lt;cmd&gt;
$ echo HelloWorld &amp;gt; myrandfile
&lt;/cmd&gt;&lt;br&gt;
&lt;cmd&gt;
$ openssl gendsa -out dsa512_3.key -rand myrandfile dsa512.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;h3&gt;生成DH密钥参数&lt;/h3&gt;

&lt;p&gt;DH密钥参数生成方法非常简单，只需要一条命令：&lt;br&gt;
&lt;cmd&gt;
$ openssl gendh -out db512.pem 512
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;那么生成的结果中内容有什么呢，可以用另一条命令：&lt;br&gt;
&lt;cmd&gt;
$ openssl dh -in db512.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/10.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;这玩意具体什么意思呢，你也别问我，我现在也还没搞懂，等搞懂了再说。 &lt;/p&gt;

&lt;p&gt;密钥协商的过程是通过调用API进行的，所以通常都需要将上面的密钥参数写到代码中，为了便于代码移植，dh指令提供了-C参数，用于C代码格式的调用（好贴心呢）：&lt;br&gt;
&lt;cmd&gt;
$ openssl dh -in db512.pem -noout -C
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/11.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;h3&gt;生成RSA密钥&lt;/h3&gt;

&lt;p&gt;RSA密钥生成非常简单，一行指令轻松搞定，格式如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl genrsa -out rsaprivkey.pem 1024
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;想要查看密钥中的内容，可以使用如下指令：&lt;br&gt;
&lt;cmd&gt;
$ openssl rsa -in rsaprivkey.pem -text -noout 
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/12.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;这一大堆都是什么东西呢，也是别问我，去问那帮搞密码学的数学家吧，他们会告诉你的。&lt;/p&gt;

&lt;h2&gt;公钥提取&lt;/h2&gt;

&lt;p&gt;由于DH算法无公私钥机制，所以这里提到的公钥提取，只涉及DSA公钥和RSA公钥。&lt;/p&gt;

&lt;h3&gt;提取DSA公钥&lt;/h3&gt;

&lt;p&gt;从DSA密钥文件提取DSA公钥的方法很简单，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsa -in dsa512_2.key -out  dsapubkey.pem -pubout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;查看公钥内容：&lt;br&gt;
&lt;cmd&gt;
$ openssl dsa -in dsapubkey.pem -pubin -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/13.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;对比“生成DSA密钥”章节的截图可以发现，公钥实际上是密钥文件的一部分。&lt;/p&gt;

&lt;h3&gt;提取RSA公钥&lt;/h3&gt;

&lt;p&gt;从RSA密钥文件提取RSA公钥的方法很简单，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl rsa -in pub.pem -pubin -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;查看公钥的内容：&lt;br&gt;
&lt;cmd&gt;
$ openssl rsa -in pub.pem -pubin -text -noout
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_27_20_20/14.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;可以看到，RSA公钥同样只是密钥文件中的一部分，可以去对比下“生成RSA密钥”章节中的截图。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇学习笔记记录了OpenSSL中和非对称加解密算法相关的一些潜在知识，并不完全，与之相关的其他内容将在下一篇学习笔记中继续完善。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>从百度证书开始(一)</title>
        <link href="http://rootkiter.com/2015/08/25/%E4%BB%8E%E7%99%BE%E5%BA%A6%E8%AF%81%E4%B9%A6%E5%BC%80%E5%A7%8B.html"/>
	<updated>2015-08-25T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/08/25/从百度证书开始</id>
	<content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在读OpenSSL的命令参数，在这个学习过程中发现OpenSSL之中，架构了一个非常庞大的理论系统，结果原以为学习一两天就能学完的基础知识，整整学了两个星期，才学到一些皮毛。&lt;/p&gt;

&lt;p&gt;这里先整理一个阶段性的学习笔记，其他学习笔记将在后面继续整理。在这篇学习笔记中，将包含一个相对完整的证书周边的知识，以及与之相关的OpenSSL指令用法。为了让这篇笔记看起来更连贯，将以百度的证书为起点展开证书体系的介绍。  &lt;/p&gt;

&lt;h2&gt;百度的证书&lt;/h2&gt;

&lt;h3&gt;获取百度的HTTPS证书&lt;/h3&gt;

&lt;p&gt;在OpenSSL中，提供了一个s_client选项，它可以模拟一个访问https的客户端。利用这个客户端可以很方便的获取到HTTPS的证书信息。&lt;br&gt;
命令如下所示：&lt;br&gt;
&lt;cmd&gt;
$ openssl s_client -connect baidu.com:443&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;命令执行后，会在控制台中打出一整段格式怪异的执行结果，它包含两个部分 : 证书相关的内容 + 实际https会话相关信息。  &lt;/p&gt;

&lt;h3&gt;证书链&lt;/h3&gt;

&lt;p&gt;s_client这条命令执行完，可以在结果中看到这样一块区域，名字为：Certificate chain。如下图所示：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/1.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;可以看到它包含 0/1/2 三段标示，每个标示都指代着一条证书记录。  &lt;/p&gt;

&lt;p&gt;标示0：从它的s字段，可以看出这个证书的所属者为百度（O=BeiJing Baidu Netcom Science Technology），它的注册地点为北京，是一家中国公司（C=CN/ST=beijing）。颁发这个证书的认证机构（所谓的CA）信息在i字段中，他是由G3 这个证书签发的。  &lt;/p&gt;

&lt;p&gt;类似的，在标示1中，可以看到G3 这个CA的证书又是由G5这个CA签发的。 在标示2中，G5证书又是由Public Primary Certification Authority.签发的。  &lt;/p&gt;

&lt;p&gt;看到这里，“证书链”的概念就容易理解了，根CA为了自身管理的方便，会将证书的签署权限依次下发给其他CA，本例中就是签署了G5，阅读G5的OU内容可以看到该机构只负责颁布证书。G5又签署认证了G3于是G3又合法了。最后，G3就签署了百度的证书。  &lt;/p&gt;

&lt;p&gt;从认证流程来看，在“证书链”中，只要有一个证书认证出现问题，那么处于证书链后方的所有证书都将认证失败。  &lt;/p&gt;

&lt;h2&gt;证书内的信息&lt;/h2&gt;

&lt;h3&gt;提取证书&lt;/h3&gt;

&lt;p&gt;证书链字段下方，就是百度的证书内容了，它被一个起始和终止标签包围，如下所示：
&lt;cmd&gt;&lt;br&gt;
-----BEGIN CERTIFICATE-----&lt;br&gt;
MIIGaTCCBVGgAwIBAgIQN23AqZqLxKVCT8qo88qpAzANBgkqhkiG9w0BAQUFADC&lt;br&gt;
...&lt;br&gt;
...balabala...&lt;br&gt;
...&lt;br&gt;
CIhENC7RHoQqph7JJQ==&lt;br&gt;
-----END CERTIFICATE-----&lt;br&gt;
&lt;/cmd&gt;
想要阅读这一堆字符所包含的信息，就需要用到OpenSSL的另一条指令：&lt;br&gt;
&lt;cmd&gt;
$ openssl x509 -in baidu.pem -inform PEM -noout -text&lt;br&gt;
&lt;/cmd&gt;
在这条命令内，用到了x509指令中的几个选项，它们的含义如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; in参数指定一个证书录入路径，&lt;br&gt;&lt;/li&gt;
&lt;li&gt; inform参数标示该文件的格式，这种base64编码类型的证书串为PEM格式，当编码无法直接可读时一般为DER编码。&lt;br&gt;&lt;/li&gt;
&lt;li&gt; -noout参数表明该指令不会生成新文件，以免占用本地磁盘空间。&lt;br&gt;&lt;/li&gt;
&lt;li&gt; -text   参数会告诉x509指令将证书的所有信息以可直接阅读的方式输出。&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于该指令参数需要从一个文件中读取证书内容，所以，首先要把百度的证书保存为一个名为baidu.pem的文件。如下图所示：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;解析证书中的字段&lt;/h3&gt;

&lt;p&gt;X509指令执行完毕后，在控制端就可以得到证书的详细内容，下面将对其中部分字段做详细解释。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;序列号字段，指明了该证书的序列号，该序列号在同CA下唯一。&lt;br&gt;
&lt;em&gt;Serial Number: 37:6d:c0:a9:9a:8b:c4:a5:42:4f:ca:a8:f3:ca:a9:03&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;签发方式字段，指明了该证书的签名算法&lt;br&gt;
&lt;em&gt;Signature Algorithm: sha1WithRSAEncryption&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Issuer字段，指明了该证书的颁发者信息，百度这个证书是由G3颁发的。&lt;br&gt;
&lt;em&gt;Issuer: C=US, O=VeriSign, Inc., OU=VeriSign Trust Network, OU=Terms of use at https://www.verisign.com/rpa (c)10, CN=VeriSign Class 3 International Server CA - G3&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Validity字段，指明了证书的有效期，有趣的是证书有效期竟然使用排除法描述。&lt;br&gt;
&lt;em&gt;Not Before: Apr 16 00:00:00 2015 GMT
Not After : Apr 16 23:59:59 2016 GMT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Subject字段，指明了本证书的主体描述&lt;br&gt;
&lt;em&gt;Subject: C=CN, ST=beijing, L=beijing, O=BeiJing Baidu Netcom Science Technology Co., Ltd, OU=service operation department, CN=www.baidu.cn&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Subject Public Key Info字段，指明了证书中的公钥详细信息。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Subject Alternative Name字段，指明了该证书同样适用的几个域名。&lt;br&gt;
&lt;em&gt;DNS:baidu.cn, DNS:baidu.com, DNS:baidu.com.cn, DNS:w.baidu.com, DNS:ww.baidu.com, DNS:www.baidu.cn, DNS:www.baidu.com.cn, DNS:www.baidu.com.hk, DNS:www.baidu.hk, DNS:www.baidu.net.au, DNS:www.baidu.net.my, DNS:www.baidu.net.ph, DNS:www.baidu.net.pk, DNS:www.baidu.net.tw, DNS:www.baidu.net.vn, DNS:wwww.baidu.com, DNS:wwww.baidu.com.cn&lt;/em&gt;&lt;br&gt;
可以看到这些域名都是百度公司自己的域名。  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Basic Constraints字段，指明该证书是否可用于CA验签，如果可用于验签则其值为TRUE。&lt;br&gt;
&lt;em&gt;CA:FALSE&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Key Usage字段，该字段指明该证书的用途，百度这个证书是用于数字签名，和密钥加密&lt;br&gt;
&lt;em&gt;Digital Signature, Key Encipherment&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Extended Key Usage字段，指明该证书的扩展用途，百度这个证书还可以用于TLS服务验证、TLS客户端验证、Netscape服务的加密&lt;br&gt;
X509v3 Extended Key Usage: 
&lt;em&gt;TLS Web Server Authentication, TLS Web Client Authentication, Netscape Server Gated Crypto&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Certificate Policies字段，是一个扩展字段。应该是由CA要求填写的一个字段。&lt;br&gt;
&lt;em&gt;X509v3 Certificate Policies:&lt;br&gt;
Policy: 2.16.840.1.113733.1.7.54&lt;br&gt;
CPS: https://d.symcb.com/cps&lt;br&gt;
User Notice:&lt;br&gt;
Explicit Text: https://d.symcb.com/rpa&lt;/em&gt;&lt;br&gt;
可以看到该字段中描述了一些赛门铁克相关的网址链接。事实上百度的这个证书正是由赛门铁克颁发的。  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 Authority Key Identifier字段，指明了G3的证书序列号&lt;br&gt;
&lt;em&gt;keyid:D7:9B:7C:D8:22:A0:15:F7:DD:AD:5F:CE:29:9B:58:C3:BC:46:00:B5&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;X509v3 CRL Distribution Points，当前的CRL列表，当证书失效或被窃取后，需要将出问题的证书在对应的CA签发机构进行吊销（就是令相应证书失效），每个CA机构都会为自己签发的证书维护一个吊销列表，当某个证书在吊销列表中时，对该证书的验签将会失败。&lt;br&gt;
&lt;em&gt;Full Name:
URI:http://se.symcb.com/se.crl&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Authority Information Access，和签发CA有关的信息，从内容看一个为在线的CRL服务地址，另一个为CA的证书地址。&lt;br&gt;
&lt;em&gt;OCSP - URI:http://se.symcd.com
CA Issuers - URI:http://se.symcb.com/se.crt&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Signature Algorithm，这个字段的内容为CA机构提供的数字签名结果，证书验证者用CA提供的公钥解密这个字段值后，会得以上所有内容的一个摘要信息，通过比对这个摘要信息结果，可以确定证书的合法性。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/4.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;证书中关键信息回顾&lt;/h3&gt;

&lt;h4&gt;证书主体框架&lt;/h4&gt;

&lt;p&gt;通过3.2章节的介绍，可以了解，一个证书是由“公钥数据”+“证书适用范围及其他扩展信息”+“CA的认证签名”三个主要部分组成，其中“CA的认证签名”也只负责前两个主要部分的校验，并保证这两个部分的数据没有更改、替换或遗失。  &lt;/p&gt;

&lt;h4&gt;签名算法&lt;/h4&gt;

&lt;p&gt;百度这个证书中，用到的是sha1WithRSAEncryption签名算法，这个算法名由两个部分组成，分别为sha1和RSA，其中RSA为非对称加密算法，正好可以解决身份认证的问题，但该算法在实际使用中有短板，那就是只能加密定长（加密长度取决于密钥长度）的数据（证书中需要认证的数据远大于这个长度），如果使用分组加密模式，加解密的过程又非常耗时，为了解决这两个问题，就引入了信息摘要算法sha1，将需要加密的数据首先做一次摘要，生成一个定长的摘要结果，再对这个定长的摘要结果进行非对称认证就可以迅速解决问题了。 &lt;/p&gt;

&lt;h4&gt;证书验证相关指令&lt;/h4&gt;

&lt;p&gt;实际使用中，证书的验证过程相对比较复杂，不但要验证证书是否由合法CA签发，还要验证这个证书是否已经被吊销过。这一小节就将对这两个操作分开说明。&lt;/p&gt;

&lt;h5&gt;证书验证&lt;/h5&gt;

&lt;p&gt;OpenSSL提供了verify指令以便我们验证证书合法性。下面我们继续以百度这个证书为例，来看一下如何校验证书。&lt;br&gt;
想要验证百度的这个证书，首先要有其对应CA的证书，在证书中提供了一CA证书的下载地址，直接wget即可得到。&lt;br&gt;
&lt;cmd&gt;
$ wget http://se.symcb.com/se.crt&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;得到证书后，可以发现该证书是一个DER编码的证书，而OpenSSL大多数指令都要求输入的文件编码为PEM编码，于是，需要对其进行一次格式转换，指令如下： 
&lt;cmd&gt;&lt;br&gt;
$ openssl x509 -in se.crt -inform DER -out se.pem -outform PEM
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;编码转换完，就可以用se.pem来验证baidu.pem这个证书的合法性了。命令如下所示:  &lt;/p&gt;

&lt;p&gt;&lt;cmd&gt;
$ openssl verify -CAfile se.pem baidu.pem&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;PS:在ubuntu下，OpenSSL的可信根证书在 /usr/lib/ssl/certs/ 目录下，在这里可以找到G5 的证书，不过由于签发时间有更改，所以证书序列号有改动，但证书公钥完全相同。  &lt;/p&gt;

&lt;h5&gt;吊销凭证&lt;/h5&gt;

&lt;p&gt;证书在使用中，可能会遇到密钥被窃、密钥遗失等问题，这些问题一旦出现，就需要对已经颁发的证书进行吊销，使其失效。实现这个机制的方案就是由CA机构维护一个证书的吊销列表，当证书被吊销时，会将这个证书的序列号就添加到吊销列表（CRL）中。&lt;br&gt;
百度这个证书是由赛门铁克签发，所以其对应的吊销列表（CRL）也由赛门铁克维护，在证书中给出了获取该列表的URI，即http://se.symcb.com/se.crl，可以直接使用wget命令将其下载至本地：&lt;br&gt;
&lt;cmd&gt;
$ wget http://se.symcb.com/se.crl&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;下载到这个证书后，同样可以使用OpenSSL的crl指令来阅读其内容，指令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl crl –in se.crl –inform DER –text –out result.txt&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;指令执行完毕，可以在result.txt文件中看到crl列表的具体内容， 通过查看该文件，可以发现，该文件的内容也是相对比较复杂的，除了包含必要的CRL介绍信息（Issuer、Last Update、Next Update、CRL Number、Authority Key Identifier、Revoked Certificates）外，结果文件中还包含着对这些内容信息的签名，签名算法同样是使用sha1WithRSAEncryption，这个签名是为了防止伪造CRL文件的，为其签名者同样是G3证书。&lt;br&gt;
在吊销列表中可以发现，被吊销过的证书有25194之多（2015年8月12日的CRL列表），随着时间的继续，该数量还会继续增加，crl文件的大小也会继续增加，这意味着查找证书序列号会越来越耗时，为了解决这个问题，CA机构一般都会提供一个在线服务（OCSP）来支持快速验证。百度的证书中也给出了赛门铁克公司的OCSP地址:http://se.symcd.com，我们同样可以通过该服务来实现在线验证一个证书是否被吊销过，查找命令在OpenSSL中同样有提供，命令格式如下：&lt;br&gt;
&lt;cmd&gt;
$ openssl ocsp -issuer se.pem -cert baidu.pem -url http://se.symcd.com -respout resp.der -text -CAfile se.pem
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;事实上OpenSSL官网给出的ocsp查询指令示例（https://www.openssl.org/docs/apps/ocsp.html）不包含CAfile选项，但本人测试时发现，如果不加该选项，执行结果会报“Response Verify Failure” 这个错误，这表明本地openssl对ocsp的回复合法性存疑，即无法确定回复确实是由赛门铁克公司给出的ocsp结果。只有添加了CAfile参数并将其指定为赛门铁克的公钥证书时才可以认证通过，估计这可能是openssl官网在写样例命令时的一个疏忽吧。&lt;br&gt;
这些问题都解决后，命令就可以成功执行了，最后给出的结论为baidu.pem: good 证明百度这个证书没有被吊销过。如下图所示：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/5.png&quot; alt=&quot;rootkiter.com&quot;&gt;    &lt;/p&gt;

&lt;p&gt;事实上吊销凭证的查询还有另一种方式，当我们掌握了被查询证书的序列号后，就可以直接递交序列号来查询，百度证书序列号的查询方法可以用以下命令：&lt;br&gt;
&lt;cmd&gt;
$ openssl x509 -in baidu.pem -serial -noout&lt;br&gt;
serial=376DC0A99A8BC4A5424FCAA8F3CAA903&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;那么此时，ocsp的查询指令就变为了：&lt;br&gt;
&lt;cmd&gt;
$ openssl ocsp -issuer se.pem -serial 0x376DC0A99A8BC4A5424FCAA8F3CAA903 -url http://se.symcd.com -respout resp.der  -text -CAfile se.pem&lt;br&gt;
&lt;/cmd&gt;&lt;/p&gt;

&lt;p&gt;如果证书被吊销过，会显示什么结果呢，我们从刚才看到的crl吊销列表随便找一个被吊销过的证书序列号：0106CCE3880F7C2E74140912A0CC379E，然后查询一下它，就得到如下结果：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_25_22_01/6.png&quot; alt=&quot;rootkiter.com&quot;&gt;   &lt;/p&gt;

&lt;p&gt;从这个查询结果中可以看出该证书于2011年12月12日被吊销，吊销原因为：密匙数据外泄。&lt;/p&gt;

&lt;h2&gt;面临的威胁及影响&lt;/h2&gt;

&lt;h3&gt;来自CA的威胁&lt;/h3&gt;

&lt;p&gt;CA是互联网证书体系的根基，一旦CA出现问题，互联网上的证书认证必将混乱。从宏观来看，证书体系对技术的要求并不是很高，一台装有OpenSSL的机器就可以轻松模拟一个CA机构。所以对于一个CA机构来说，最难掌控的部分在于如何维护它的合法性，能够威胁其合法性的情况大体有以下几种情况（个人可以预见的几点，必然不够全面）：  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CA私钥泄漏：这是最危险的情况，因为私钥持有者可以拿着私钥随意签名，随意颁布吊销列表，整个互联网将没有任何信任可言。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;CA私钥遗失：仅次于私钥泄漏，CA的多数操作（证书签发、证书续约、颁发吊销列表等）都是依赖CA私钥进行的，丢失了私钥的CA将完全无法正常工作。&lt;/li&gt;
&lt;li&gt;证书颁发流程不严谨：一个CA在颁布一个合法证书前，要对客户进行非常完善的调查（申请人是不是合法公民？证书的使用范围是否超越常理？等等），这套机制不亚于公安机关办案。在这套流程中一旦出现问题，后果是非常严重的，一个只需要普通证书的用户却得到了一个CA证书，那他就可以拿着这个证书去给别人颁发证书赚钱了呢。这样的CA能被人信任就怪了。&lt;/li&gt;
&lt;li&gt;证书吊销流程不严谨：如果这个流程不够严谨，就意味着我看谁的证书不爽，我就可以去告诉CA吊销了它。这也会给互联网的认证机制造成混乱。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;算法层威胁&lt;/h3&gt;

&lt;p&gt;这是一种来自数学层面的攻击，从证书的颁发和认证流程就可以看出它的核心工作流程是基于非对称加密算法实现的，一旦这些认证算法，或者签名算法出现问题，这也会引起认证体系的混乱。和百度证书认证有关的算法，叫做sha1WithRSAEncryption，它由两部分组成：信息摘要算法（sha1）+非对称加密算法（RSA）。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信息摘要算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;摘要算法的基本数学描述为：对一段数据m进行信息摘要得到结果z，摘要算法为H(x)，则 z=H(m)。&lt;br&gt;
在签名机制中，摘要算法面临的主要攻击是，找到相同摘要结果的不同定制数据。数学描述就是：已知 H(m1)=z 的情况下，很难找到一个有特定意义的m2 另 H(m2)=z也同时成立。一旦攻击者能够很容易找到m2 数据的构造方法，他就可以将自己的密钥对封装在m2中，并复用m1的签名结果，进行签名伪造(不同私钥共用相同签名的状态)。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;非对称加密算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;非对称算法在身份认证机制中，主要用到的是公私钥唯一对应关系，即公钥加密的数据只能由私钥进行解密，同时私钥加密的数据只能由公钥进行解密。那么它面临的攻击将有两个方面：  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可通过公钥很容易的推出私钥，这种情况意味着私钥的直接泄漏。认证体系自然会混乱。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;可通过公钥找到另一个私钥，这种情况虽然不是私钥直接泄漏，但威胁同泄漏私钥的结果是相同的，认证体系也同样会混乱。&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;私钥泄漏威胁&lt;/h3&gt;

&lt;p&gt;前面在CA威胁中提到过CA私钥泄漏的情况，这里与之的区别在于泄漏私钥的主体为用户。实际生活中，普通用户对于密钥体系的理解可能会存在误区，导致错误使用私钥，进而泄漏私钥。我这里可以想到的两个误区为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对密钥文件的理解误区：了解过OpenSSL指令体系的同学一般都会知道，直接从OpenSSL生成的公钥和私钥一般都存储在同一文件中，如果用户在使用中（一般是公钥公布的环节）没有注意到这一个细节，就会造成私钥的泄漏。&lt;/li&gt;
&lt;li&gt;对公私钥体系的理解误区：学习过公私钥资料的同学通常会很自然的认为，公私钥权利是等价的：“公钥加密，私钥解密”，或“私钥加密，公钥解密”。他们觉得只要把其中一个称为公钥，而另一个称为私钥即可，而不用在意其顺序。在这种错误的观念下很容易把两者用反，最终导致私钥泄漏。从公钥无法反推出私钥是有大量的数学推导提供安全保障的，而反过来则不存在安全保障。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;综上所述，证书管理及验证是一套非常庞大的体系，建造一个完备的证书认证系统也是存在一定困难的。身份认证机制并不只在https通信中有应用，它在银行行业中化身为Ukey，网络当中有些功能重要的服务器为了防止密码暴力破解也采取了密钥证书的身份认证机制。  &lt;/p&gt;
</content>
</entry>

<entry>
	<title>Android下的NDK</title>
        <link href="http://rootkiter.com/2015/08/06/Android%E4%B8%8B%E7%9A%84NDK.html"/>
	<updated>2015-08-06T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/08/06/Android下的NDK</id>
	<content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;这也是很久之前写的一篇学习笔记，刚翻出来瞅了一眼，有些小细节还是已经有些过时了，看来技术的变更速度真的是太快了。既然也是曾经的劳动成果，那就同样拿出来简单的整理一下吧。&lt;/p&gt;

&lt;p&gt;该笔记参考http://blog.sina.com.cn/s/blog_61b056970100sy0u.html博文而成。&lt;/p&gt;

&lt;h3&gt;环境搭建&lt;/h3&gt;

&lt;p&gt;首先，jdk，eclipse，android sdk ，android ndk ，cygwin ，cdt，adt你肯定要安装好吧，没安装好的同学请百度下相关配置教程，这不是我文章的重点。  &lt;/p&gt;

&lt;h2&gt;编写helloworld&lt;/h2&gt;

&lt;h3&gt;编写Jni接口：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在资源目录下创建 jni.java文件
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;声明jni接口
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;命令行模式下进入src目录执行javac jni.java&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将生成的 .class 文件拷贝到 /bin 目录下的对应路径并覆盖
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/4.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令行进入 /bin/classes/ 目录 执行javah  –jni com.example.killndk.Jni  生成一个 .h  文件：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/5.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在根目录下创建jni文件夹用于保存C程序代码，并将刚生成的.h文件拷贝进去：  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以jni目录为根目录建立C工程，添加C源码以及.mk  文件。
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/6.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
&lt;a href=&quot;/files/Android.txt&quot;&gt;Android.mk&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;/files/com_example_killndk_Jni.txt&quot;&gt;com_example_killndk_Jni.c&lt;/a&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在android工程上配置编译选项：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/7.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左侧选择Builders，右侧选择New按钮，添加编译选项：&lt;br&gt;
填写编译配置信息：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/8.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这一页主要是填写与cygwin相关的绝对路径，以及工程的绝对路径，各位需要根据实际情况予以调整。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/9.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C代码被编译后会放在libs目录下。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/10.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C的相关代码放在jni目录下。&lt;br&gt;
配置完成后，每次jni文件夹发生变化，就会自动执行makefile命令了。  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在可以通过Jni定义的接口来访问C语言函数了：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/11.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;看看执行效果吧，还算不错：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/12.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;编写内嵌汇编&lt;/h2&gt;

&lt;p&gt;由于NDK的C代码是通过gcc编译而成的，则必然支持内嵌汇编式的编程，并通过汇编方式实现C语言无法实现的功能，下面就介绍一下通过NDK如何进行内嵌汇编式编程。  &lt;/p&gt;

&lt;p&gt;注意：gcc本身的去除冗余效率是非常高的，除极特殊原因不建议使用内嵌汇编式编程。&lt;/p&gt;

&lt;p&gt;内嵌汇编式编程同其它NDK编程基本类似，需要注意的是Arm的函数调用方式采用快速调用的方法，形参均通过寄存器进行直接传递，在编写内嵌汇编程序时要注意形参同寄存器的对应关系。下面给出“参数加一函数”的内嵌汇编实现。
&lt;img src=&quot;http://rootkiter.com/images/2015_08_06_22_43/13.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;可以看出，key的值被自动关联为R2寄存器，且返回值也被自动的关联为R0寄存器。&lt;/p&gt;

&lt;p&gt;如果想要关注更多关于gcc for arm下的内嵌汇编编程可以参照这篇文章&lt;a href=&quot;www.ethernut.de/en/documents/arm-inline-asm.html&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;结束&lt;/h2&gt;

&lt;p&gt;13年的学习笔记，现在看就有些过时了。知识更新真是太快了。。。当时高考报志愿，怎么就偏偏选了这么一个专业呢。。。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ARM指令结构和crack思路</title>
        <link href="http://rootkiter.com/2015/08/05/ARM%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84%E5%92%8Ccrack%E6%80%9D%E8%B7%AF.html"/>
	<updated>2015-08-05T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/08/05/ARM指令结构和crack思路</id>
	<content type="html">&lt;h2&gt;写在开头&lt;/h2&gt;

&lt;p&gt;很久之前写了一些围绕ANDROID和ARM的学习笔记，前段时间已经整理过&lt;a href=&quot;http://rootkiter.com/2015/07/04/ARM%E4%B8%8B%E7%9A%84ShellCode.html&quot;&gt;一篇&lt;/a&gt;，这是另一篇。这里记录了一些围绕着ARM指令系统的知识。&lt;/p&gt;

&lt;p&gt;ARM指令系统是由ARM公司定义的一类芯片的指令规则，这种芯片普遍应用于各种便携式设备，以及智能终端中，具有低功耗，便于开发等特点。 &lt;/p&gt;

&lt;h3&gt;ARM指令系统同X86指令的区别&lt;/h3&gt;

&lt;p&gt;从指令长度上看，ARM指令属于定长指令系统，每一条指令都为固定的4字节长度，而X86却是变长，长度取决于指令本身的复杂程度。  &lt;/p&gt;

&lt;p&gt;从CPU架构上看，ARM指令系统拥有着更多的寄存器供开发者使用(31个通用寄存器和6个状态寄存器)，与之相对的X86寄存器数量便少的可怜了，这一问题也在X64指令中得到了很大程度大缓解。  &lt;/p&gt;

&lt;p&gt;以上两点仅是比较明显的区别，也是ARM同X86相比更优秀的地方，如果想要了解更详细的区别可以通过网络自行检索，这里就不细致描述了。  &lt;/p&gt;

&lt;h3&gt;Arm指令格式介绍&lt;/h3&gt;

&lt;p&gt;前面提到：ARM 指令是定长指令，长度为4个字节（32位二进制位），这样做的好处之一是便于CPU寻址，而另一个好处就是在指令定义时，可以人为固定一些特殊的标志位，用于确定指令的执行规则。ARM指令的一般编码形式如下：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/1.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
其中：&lt;br&gt;
&amp;nbsp;&amp;nbsp;cond 指令执行的条件码；&lt;br&gt;
&amp;nbsp;&amp;nbsp;opcode 指令操作编码&lt;br&gt;
&amp;nbsp;&amp;nbsp;S 决定指令的操作是否影响CPSR（状态寄存器类似于X86中的flag寄存器）的值&lt;br&gt;
&amp;nbsp;&amp;nbsp;Rd   目标寄存器编码（通过二进制序列描述各种寄存器）&lt;br&gt;
&amp;nbsp;&amp;nbsp;Rn 包含第一个操作数的寄存器编码。&lt;br&gt;
&amp;nbsp;&amp;nbsp;Shifter&lt;em&gt;operand  表示第二个操作数&lt;br&gt;
随后规定了一条ARM指令语法模版：&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;lt;opcode&amp;gt;{&amp;lt;cond&amp;gt;}{S}  &amp;lt;Rd&amp;gt;,&amp;lt;Rn&amp;gt;,&amp;lt;shifter&lt;/em&gt;operand&amp;gt;&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过上面的描述不难发现，在指令序列中有一个名称为cond的片段，是X86指令序列中所没有的，该序列决定了当前指令是否会被执行，换句话说，通过修改这个字段，就可以实现程序逻辑的修改。&lt;/p&gt;

&lt;h3&gt;cond片段的含义&lt;/h3&gt;

&lt;h4&gt;影响程序执行流程的标志&lt;/h4&gt;

&lt;p&gt;从X86的汇编指令中我们可以得知，指令执行过程中会出现如下几种情况：&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;em&gt;1.指令执行结果为“0”&lt;/em&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;em&gt;2.指令执行结果出现溢出&lt;/em&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;em&gt;3.指令执行结果为负&lt;/em&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;em&gt;4.两个操作数的大小判别&lt;/em&gt;&lt;br&gt;
这些情况将会决定后续程序的执行流程，在Flag寄存器中会找到它们的身影。相同的情况ARM指令系统同样也考虑到了，并且将这些情况通过CPSR寄存器（类似X86中的FLAG寄存器）中进行存储，并为它们命名为：Z、V、N、C 四个标志位。CPU通过访问CPSR寄存器的状态便可以确定程序的执行流程。&lt;/p&gt;

&lt;h4&gt;条件码以及助记符的对应关系&lt;/h4&gt;

&lt;p&gt;通过cond片段的条件码，可以对CPSR寄存器进行相应的访问，为了便于记忆，特规定了一些助记符，它们之间的对应关系可以参照下图：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;h4&gt;如何使用cond片段&lt;/h4&gt;

&lt;p&gt;到目前为止，ARM指令系统基本已经熟悉了，可以进行一些破解的思索了，从crackme的游戏规则可以知道：crackme其实就是让一段指令片段在“执行”同“不执行”之间转换，从而达到破解的目的。  &lt;/p&gt;

&lt;p&gt;在X86中“爆破”通常都是通过修改jmp，cmp的操作数、或Flag标志位，来crack程序的。这些方法同样适用于ARM平台，然而通过以上对于cond片段的了解不难发现：&lt;br&gt;
如果修改了cond片段的值同样也能够达到crack的目的，只需修改一位二进制位即可完成BNE到BEQ的转化，修改四位二进制位即可让一条指令失效，或让其无条件执行，可以说，手握“条件码同助记符对应表”即可决定ARM程序中每一条指令的生死。&lt;/p&gt;

&lt;h3&gt;通过crackme来验证cond片段的功效&lt;/h3&gt;

&lt;h4&gt;如何获得crackme&lt;/h4&gt;

&lt;p&gt;从各大破解论坛游走一圈之后，并没有找到 ARM 版的crackme，原因大概在于大牛们不屑于 ARM 平台的破解尝试，也可能是ARM平台本来就没有什么值得破解的东西。好在以前编写过 windows 的 crackme ，既然没有那么就自己写一个吧，随便弄一个弱智的功能测试一下修改cond的效果。ARM下的编程语言，除了特定的汇编语言、C语言以外，似乎没有发现其他的嵌入式原生开发的语言，既然我喜欢C语言那么就用C语言实现一个傻瓜式的crackme吧。&lt;/p&gt;

&lt;h4&gt;Crackme的构思&lt;/h4&gt;

&lt;p&gt;既然已经定义为“傻瓜式”的crackme了，那就自然要有一个傻瓜式的规则，提示用户输入一个字符，如果输入的是‘a’则提示crack成功，否则提示失败。
具体的C实现代码如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
代码编写完毕利用交叉编译器生成arm平台对应的二进制可执行文件。
运行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/4.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;效果还不错，现在不输入‘a’是不会提示OK的了。下面的目标就是：输入除‘a’以外的其他key都会提示“OK：You crack me now !”&lt;/p&gt;

&lt;h3&gt;开始Crack&lt;/h3&gt;

&lt;h4&gt;破解准备&lt;/h4&gt;

&lt;p&gt;Crack必须的工具有两个，一款好用的调试器，和一个16进制文件编辑器，由于crackme并不复杂，IDA 61 +  C32Asm足以。
首先用IDA61打开crackme，并进行简单的分析，如下图所示：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/5.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;简单看一下都是比较基础的ARM指令，没有什么难度，关键跳转一目了然：“BNE loc_8228”，只需要将BNE改为BEQ，或者B，即可跳转到输出“OK”的分支。既然如此马上动手。&lt;/p&gt;

&lt;h4&gt;找到cond片段&lt;/h4&gt;

&lt;p&gt;通过IDA的HEX标签查看可以得知：BNE所对应的指令片段为：02 00 00 1A，如下图所示：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/6.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
由于ARM指令在文件中为字节倒序排列，所以其中1A 的1  便是cond片段的值，将其修改为：0A 即可将BNE指令变为BEQ，貌似IDA不支持修改源文件，那么就在C32Asm中修改吧。&lt;/p&gt;

&lt;h4&gt;用C32Asm进行代码变更&lt;/h4&gt;

&lt;p&gt;通过C32Asm的16进制查找功能定位到该序列处，并将1A修改为0A（BNE-&amp;gt; BEQ）然后保存修改结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/7.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
最后用IDA载入查看修改后的程序流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/8.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
可以发现，该指令已经变为预期的BEQ指令。
具体arm平台测试结果如下图所示：
&lt;img src=&quot;http://rootkiter.com/images/2015_08_05_22_34/9.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;可以发现，输入‘a’同输入‘b’得到的返回值发生了交换，证明程序的流程被有效的修改了，crack成功，现在就可以根据自己的要求修改指令中的cond片段从而达到crack的目的了。&lt;/p&gt;

&lt;h2&gt;结束&lt;/h2&gt;

&lt;p&gt;以上介绍了ARM平台下通过修改cond条件码的方法达到crack程序的目的，通过这种方式可以任意的修改程序执行流程，所需要的仅是“IDA + 16进制编辑器 + 条件码助记符对应表”的组合，可以说难度并不是很大。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>Jekyll页面的索引实现</title>
        <link href="http://rootkiter.com/2015/07/14/Jekyll%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0.html"/>
	<updated>2015-07-14T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/07/14/Jekyll页面的索引实现</id>
	<content type="html">&lt;h2&gt;起因&lt;/h2&gt;

&lt;p&gt;一直觉得博客还缺些什么，思考过后，发现博客还缺一个快速定位文章的功能，于是实现了&lt;a href=&quot;/goto_tags.html&quot;&gt;这样一个页面&lt;/a&gt;，在这个页面里，可以通过标签索引来快速定位文章位置。这个页面的实现既用到了 Jekyll 的特性，也用到了 HTML 标签的一些特性。&lt;/p&gt;

&lt;h3&gt;前人做过的尝试&lt;/h3&gt;

&lt;p&gt;在Jekyll下实现文章定位，网上有很多人做过尝试，有人通过js代码实现，比如这篇《&lt;a href=&quot;http://www.tuicool.com/articles/6vA36f6&quot;&gt;Jekyll站内搜索：jekyll-lunr-js-search使用说明&lt;/a&gt;》。也有人通过添加 Ruby 插件来实现，比如这篇《&lt;a href=&quot;http://codemacro.com/2012/07/18/add-category-list-to-octopress/&quot;&gt;为octopress添加分类(category)列表&lt;/a&gt;》。这些方法，都很好，而且很简单，但我只想要一个非常基础的文章定位或分类功能。这些方法都显得复杂了。&lt;/p&gt;

&lt;h3&gt;思考后的解决方案&lt;/h3&gt;

&lt;h4&gt;1. 锚标签&lt;/h4&gt;

&lt;p&gt;浏览器实现了一个页面内快速跳转的方法，通过配置某些标签的 name 属性，即可在页面中进行插桩，此时，在浏览器地址栏使用 “#” 字符，即可快速跳到相应的标签。相关的知识细节可以参考这两篇文章《&lt;a href=&quot;http://www.w3school.com.cn/tags/att_a_name.asp&quot;&gt;HTML &lt;a&gt; 标签的 name 属性&lt;/a&gt;》和《&lt;a href=&quot;http://blog.csdn.net/qq1712088151/article/details/7402019&quot;&gt;锚标签和href属性&lt;/a&gt;》。&lt;/p&gt;

&lt;h4&gt;2. Jekyll 实现&lt;/h4&gt;

&lt;p&gt;Jekyll的文章可以支持tags来给文章打标签。一篇文章可以有具多个标签，格式如下：&lt;br&gt;
&lt;code&gt;
---&lt;br&gt;
layout: xxxxx&lt;br&gt;
title : xxxxxxxxxx&lt;br&gt;
tags  : [ tag1 , tag2 ]&lt;br&gt;
---&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于 Jekyll 的特性，我们可以通过 site.tags 来访问这些标签，这也是一种常见的Jekyll文章索引方法，关于这一特性的具体细节可以参考《&lt;a href=&quot;http://havee.me/internet/2013-11/jekyll-liquid-designers.html&quot;&gt;Jekyll 扩展的 Liquid 设计&lt;/a&gt;》，随后我在主页下方添加了如下代码：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_07_14_21_13/4.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;标签能够自动统计了。
&lt;img src=&quot;http://rootkiter.com/images/2015_07_14_21_13/1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h4&gt;3. 标签分类展示页&lt;/h4&gt;

&lt;p&gt;随后我们可以继续创建一个单独的标签分类页，用来管理博客的所有文章。核心代码如下：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_14_21_13/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以看到在这个具有分类功能的页面中，我在每个分类前加了一个具有name属性的a标签，进行锚定。此时我们就可以通过 ’＃‘ 来实现页面内定位跳转。
于是&lt;a href=&quot;/goto_tags.html&quot;&gt;这样的页面&lt;/a&gt;就实现了。
&lt;img src=&quot;http://rootkiter.com/images/2015_07_14_21_13/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;结束&lt;/h2&gt;

&lt;p&gt;通过这个方法，就可以实现文章的分类以及索引定位了。用起来感觉还挺方便的。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>《一席》中的好故事</title>
        <link href="http://rootkiter.com/2015/07/05/%E3%80%8A%E4%B8%80%E5%B8%AD%E3%80%8B%E4%B8%AD%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B.html"/>
	<updated>2015-07-05T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/07/05/《一席》中的好故事</id>
	<content type="html">&lt;h2&gt;关于《一席》&lt;/h2&gt;

&lt;p&gt;最近在听《一席》这个节目，用了大概一个月时间把每期节目过了一遍，这个栏目原本是参照《TED》来做，但现在看来这里水分确实很大，很多人都是上来推荐自己的产品，或者上这里讲些不切实际的东西，企盼吸引到投资。在这一个月听了上百期左右后找到了几个有趣的议题，下面依次介绍下（文中有视频地址）。&lt;/p&gt;

&lt;h3&gt;当梦想成为地址－王丹&lt;/h3&gt;

&lt;p&gt;讲者是个丁克家庭，夫妻两人在荒郊野岭盖了一栋房子，吸引外来的人来住讲自己的故事。而这个议题是要介绍整个过程，包括如何租土地，如何和房东博弈，如何找些乡里人盖房子，如何同来住的客人互动。很有趣的议题。&lt;/p&gt;

&lt;p&gt;蒲松龄开个茶馆，写了一本《聊斋志异》，而300年后王丹自己造了个房子，可能也能做出相似的事吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/1.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/1_1.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/1_2.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/1_3.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODUwMDI0MTEy.html?from=y1.2-2.4.42&quot;&gt;—&amp;gt;视频地址&amp;lt;—&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;裂变式创业－宗毅&lt;/h3&gt;

&lt;p&gt;作为打通中国南北充电之路的第一人。他讲了很多好玩的内部创业思路，独创的内部集资裂变式创业思路，孵化了很多很有潜质的内部创业项目。值得很多大公司借鉴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/2.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/2_1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODQ0MjYzMjg0.html&quot;&gt;—&amp;gt;视频地址&amp;lt;—&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;感谢你给我机会上场－方励&lt;/h3&gt;

&lt;p&gt;自费出资帮国家打捞“辽宁大连5.7空难的黑匣子”，同时又是国内很多著名电影的制片人，这些华丽的光环背后，他还是北京劳雷影视文化有限责任公司的总裁，这个公司是“世界上最大的集地球物理仪器开发与销售为一体的地球物理仪器公司”，可以说这家伙是个彻彻底底的牛人，用他自己的话说：“自己这一辈子，真的很成功，很高产，他这一辈子完成了别人十辈子的事。”&lt;br&gt;
在演讲中，他有个更有趣的观点：人赚钱是为了幸福生活，或未来的幸福生活，但如果为了赚钱而去做不快乐／不幸福的事，那么你就输在了起跑线上。&lt;br&gt;
另一个有趣的观点：惜命的方式，不是用来养生，而是用来折腾。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XNzg2MDQyNzYw.html&quot;&gt;—&amp;gt;视频地址&amp;lt;—&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;创业没有美感－罗军&lt;/h3&gt;

&lt;p&gt;这家伙讲了自己的两次创业历程，起初还被人看成骗子，后来终于把公司干了起来。按他的说法，旁观者希望看到的故事是有传奇经历的，然而创业者自己知道，创业是件很苦的事，毫无美感可言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_05_14_17/4.jpg&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XNzYyODM5OTEy.html&quot;&gt;—&amp;gt;视频地址&amp;lt;—&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;结束&lt;/h2&gt;

&lt;p&gt;这些人都很棒，他们做了一些超越常理的事情，自己在玩，别人在看，希望有一天也能和他们类似的做些有趣的事，开心地玩它一辈子。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ARM 架构下的 ShellCode</title>
        <link href="http://rootkiter.com/2015/07/04/ARM%E4%B8%8B%E7%9A%84ShellCode.html"/>
	<updated>2015-07-04T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/07/04/ARM下的ShellCode</id>
	<content type="html">&lt;h2&gt;引言&lt;/h2&gt;

&lt;p&gt;这是我很久以前写的一些学习 ANDROID＋ARM 的学习笔记，这是其中一篇，其他笔记会在适当的时候继续整理出来。先整理一下这一篇。&lt;/p&gt;

&lt;h2&gt;写段 HelloWorld&lt;/h2&gt;

&lt;p&gt;我编写shellcode也是从HelloWorld开始滴，下图是相应的代码截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后编译链接运行：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/2.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;ShellCode 提取&lt;/h2&gt;

&lt;p&gt;到目前为止，自己编写的ARM汇编程序已经完全可执行了，下一步就是提炼16进制的shellcode，可以通过以下命令获取16进制结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/3.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后就是固定的shellcode测试代码（C语言格式），如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/4.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;RecvShell 的 ShellCode&lt;/h2&gt;

&lt;p&gt;这段代码是网上有人给出的，但是给出的却是objdump-d 版本，在还原指令的时候遇到很多语法问题，也就顺便学了一些Thumb语法，收获挺大的，看下面的截图（可以通过右键菜单中查看原图来查看放大图）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/5.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;程序编译连接后的执行结果如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/6.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;还是利用objdump提取16进制shellcode，得到如下代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/7.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;执行后运行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_07_04_19_25/8.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;结束&lt;/h2&gt;

&lt;p&gt;这里没有高深的技术点，只是一篇学习笔记和一些很详细的操作截图。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>程序员的世界</title>
        <link href="http://rootkiter.com/2015/07/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%96%E7%95%8C.html"/>
	<updated>2015-07-02T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/07/02/程序员的世界</id>
	<content type="html">&lt;h2&gt;好久没更新博客了，今天来写点什么&lt;/h2&gt;

&lt;p&gt;在21世纪开始后，程序员成为了一种很重要的生产力。由于工作性质的特殊性，决定了他们是社会中的另类。你会发现这类人很难管理，他们经常会做出一些奇怪的举动（比如冲着电脑发呆，偶尔舒展下眉宇什么的）；甚至会为了一些工作无关的事情（通常是自然科学和谁更缺心眼这种话题）争吵很久。想要管理这些人，就要知道他们究竟是怎么想的，又是什么原因导致的。&lt;/p&gt;

&lt;h3&gt;我用的语言是世界上最完美的语言&lt;/h3&gt;

&lt;p&gt;如果你想在开发者论坛引发一阵辩论，这是百试不爽的开场白。&lt;/p&gt;

&lt;p&gt;程序设计语言千千万，每种语言都有其追随者。《JVM核心技术揭秘》这本书里说过一句类似这样的话：如果一门语言没有改变你思考问题的方式，那么你就没有学会这门语言。。。这就像中国人学英语一样，学会英语前，你会在头脑中用汉语描述一个想法或者观点，最终翻译为英语表达出来；而当你真正掌握英语后，你就会开始用英语思考，并直接说出来。后者的状态意味着你真的学会了英语。。。&lt;/p&gt;

&lt;p&gt;相似的问题也出现在程序设计语言中。各种语言的追随者掌握了自己的语言之后，他们的思考方式就开始顺从于这门语言，当新语言尝试进入他们的视线时，会发现新语言同他们思考问题的方式相左。于是抵触情绪就产生了，这种情绪越强烈，这批人就会越偏向自己原本掌握的语言。于是争论就发生了了，仔细观察双方的论点（java函数范式很难用／C++的指针很难用／python很难系粒度操作内存啊）也会得出类似的结论。&lt;/p&gt;

&lt;h3&gt;我写出的代码才是最优秀的&lt;/h3&gt;

&lt;p&gt;好的程序员一般都是完美主义者，他们会努力让自己的代码更符合自己的审美需求（包括代码逻辑，编程风格，功能逻辑等），为了达到这一目的，他们会尝试不同的方案去解决同一问题，并从中选出最优方案。所以无论代码解决的问题是大是小，都是他们倾注很大的心血完成的。在这样的前提下，他们自己的代码当然是最优秀的。&lt;/p&gt;

&lt;p&gt;其实一个程序员如果没有这种特质，那么他也不会成为一名优秀的程序员。整天被动的拷贝代码，而不去试图区分代码间异同的家伙，能优秀起来那就是贱了鬼了。&lt;/p&gt;

&lt;h3&gt;XXX连程序都不会写凭什么领导我&lt;/h3&gt;

&lt;p&gt;这种程序员有很多，有些人技术真的很优秀，而另一些却只是在挑毛病。事实上，程序员一般都思维活跃，不喜欢被束缚，在他们看来一切枷锁都是要解决掉的，如果有个人成天在他上面叽叽咕咕，胡乱指挥，他们自然会很讨厌。&lt;/p&gt;

&lt;p&gt;想要驯服这种程序员也很容易，第一种方法是最有效的，让自己比他技术更牛，程序员是很容易服从比他更牛的人的。第二种是比较容易做到的。那就是掌握任何一门有技术含量的手艺（能把office发挥的淋漓尽致也是一门有技术含量的手艺），他也会开始由衷佩服滴。第三种，效果最弱，但也可以一试，那就是把自己工作中很无趣的工作交给他一部分，当他有抱怨情绪时，再适当的透露自己每日为了应付这些事情多么的痛苦。取得他的理解后，再管理起来就会容易一些，这种方法效果最弱，只能解决一小部分问题。&lt;/p&gt;

&lt;h3&gt;工作鄙视链&lt;/h3&gt;

&lt;p&gt;程序员是一个极具创造性的职业，他们敲出代码是一个从无到有的过程，时间久了，这些人会成就感爆棚，觉得自己无所不能（创造这种事，怎么瞧都和上帝很像）。于是他们就会开始鄙视那些不动脑，甚至毫无创造性的职员。当大家都处在同一团队时，会出现协同效果不好的情况。造成这一效果的原因在于他们无法发现这些职位的创造性一面，多沟通多让他们发现这些点，会一定程度缓解这种效果。&lt;/p&gt;

&lt;h2&gt;尾巴&lt;/h2&gt;

&lt;p&gt;写了这么多，却一点都不够系统，甚至可能都没有解决任何问题，但我就是想把它写在这里，总有一天从这些点会穿成一条线，最终形成一个面。到那时这些文字就不再毫无意义了。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>3D打印</title>
        <link href="http://rootkiter.com/2015/06/13/3D%E6%89%93%E5%8D%B0.html"/>
	<updated>2015-06-13T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/06/13/3D打印</id>
	<content type="html">&lt;h2&gt;起因&lt;/h2&gt;

&lt;p&gt;最近由于痴迷3D打印，所以好久没有更新文章。搞了几天发觉终于有些入门了，就来记些心得。独自happy一下。&lt;/p&gt;

&lt;p&gt;那一日，俺去“XX奶茶店”转了一圈，看到一台3D打印机，感觉有趣，于是就回家淘了一台。价位在1500元左右，算上四盘PLA的材料不到1800元。&lt;/p&gt;

&lt;p&gt;它长这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/quanji.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;3D打印介绍&lt;/h2&gt;

&lt;p&gt;这台打印机有5个步进电机。下侧打印床可以前后移动，作为Y轴；打印头可以横向（左右）移动作为X轴；两侧的定向杆可以让打印头上下方向移动作为Z轴，每侧有一个步进电机；最后一个步进电机位于打印头上方的黑盒子中，用于控制材料流出速度（PLA材料融化后，会从打印头流出，步进电机可以控制入料的速度）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/jichudianji.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;下侧的打印床是一块方形平台，原本是金属平板，不过由于打印过程中和塑料的收缩系数差距较大（热胀冷缩的面积变化不同），所以会出现打印过程中物体在打印台上滑动的情况，为了让打印过程中，产品始终能粘在打印台上，可以做两种操作：1.贴一层抗热膜，平衡两者的系数；2.加热打印床，以免接触面过凉导致打印件脱落。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/jiaodai.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;在打印机中有3处“限位开关”，分别位于 X／Y／Z 轴的尽头处，这是防止运动过程中偏离打印机能承受的最大范围，导致打印机毁坏。我现在也把限位开关定义为打印头的原点坐标（0，0，0）。这样做的好处是不用总去计算起始坐标的偏移量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/xianweikaiguan.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;正式打印前，需要把打印床调平，这里所说的调平不是相对地平线调平，而是相对打印头的打印平面调平，最早不懂的时候我是肉眼调平，结果发现肉眼真的很不靠谱，在同事的指点下，我开始垫一张纸来调平（紧的时候纸会有摩擦力，有缝隙时则没有摩擦力），精度真心高了很多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/tiaoping.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;准备就绪后，就可以开始打印了，这台打印机配套的控制软件叫做 Repetier 。本人用了一段时间下来，觉得它还是挺好用的。打印的模型描述文件为 stl 文件。Repetier可以把这种模型文件按层切片并转换为gcode代码。其中每一层就是一个打印面；不同的层就是不同的高度，也对应着打印机中的 Z 轴。切片层越薄打印的产品就越光滑，和显示屏的像素原理类似。这台打印机目前支持的层高范围为 0.1－0.4mm 。下图是层高 0.2 的大白，可以看到还是有些层次感的。如果选择 0.1mm的层高其实会好很多，但打印时间会翻倍。这个0.2的大白，我可是打了 8 个多小时呢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/dabai.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;3D打印的观赏品一半都只注重外形，对于其内部的填充，一般不是特别看重，所以切片的时候可以选择空心填充，以缩短打印耗时。Repetier自带的切片软件叫做 Slic3r 。我只用过它的两种填充，这两种填充打出来的大白外观差距不大，但用时却差了一倍以上，后者只需打印4个小时左右，就完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/qiepian1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/qiepian2.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;打印机调好后，最让人伤神的就是模型文件了。俺不是美工出身，也没学过制图，所以模型文件是极度欠缺的。结果就是有了打印机都不知道该打点什么。在网上搜了好几天才搜到几张比较喜欢的模型图。打了一些物件，毕竟不是自己画的，打出来也不是特兴奋。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/beiz.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/hama.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/zixingche.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;为了能够让自己真的兴奋起来，我又学了几天3D制图，网上一般都推荐 3DMax／Maya 这种专业的制图软件，但都太吃计算机性能（显卡／CPU／内存什么的），找了好几天才找到一个叫 “123D Design” 的软件。这个软件很好学，网上也有&lt;a href=&quot;http://www.tuicool.com/articles/yiimquB&quot;&gt;很详细的文章&lt;/a&gt;，照着操作一次就基本会用了。目前虽然还用的不太熟练，不过基本能设计些很简单的模型了，这就是我刚打出来的一个钥匙配件喽，自我感觉很良好，哈哈。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/yaoshikou1.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_06_14_00_00/yaoshikou.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;/p&gt;

&lt;h2&gt;结尾&lt;/h2&gt;

&lt;p&gt;先写这些吧，一个月不更新，都有点生疏了。。。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>借力打力－smali代码窃取</title>
        <link href="http://rootkiter.com/2015/05/08/%E5%80%9F%E5%8A%9B%E6%89%93%E5%8A%9B_smali%E4%BB%A3%E7%A0%81%E7%AA%83%E5%8F%96.html"/>
	<updated>2015-05-08T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/05/08/借力打力_smali代码窃取</id>
	<content type="html">&lt;h1&gt;起因&lt;/h1&gt;

&lt;p&gt;这两天在分析一个apk样本，在分析中遇到了一个硬编码密文字符串的情况。
下图就是样本中的一个硬编码密文：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_1.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;其对应的解码函数为：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_2.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;要想确定上面的硬编码字符串经isInstallation这个函数还原后的原始结果，有三种思路：  &lt;/p&gt;

&lt;p&gt;1.动态调试，调试到解密位置，看寄存器的结果。&lt;br&gt;
2.重打包，在解密后的位置加段打日志的代码，然后重打包运行，就能在日志中看到解密结果了。&lt;br&gt;
3.代码窃取，它的主体思路是：将解密函数（isInstallation）的smali代码抠出来，然后我们自己写一段代码去掉用这个解密函数。  &lt;/p&gt;

&lt;p&gt;其实头两种是比较常见的做法，可惜这个样本有反调试机制，而且dex文件中有一段代码又是通过so文件动态还原的，导致头两种方法都很难有效。于是只能用最后一种方法。&lt;/p&gt;

&lt;h1&gt;操作步骤&lt;/h1&gt;

&lt;p&gt;首先按照isInstallation的定义格式（这里方法定义为公有或者私有不用较真，能调用就行），写一个段java框架代码，如下所示：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_3.png&quot; alt=&quot;rootkiter.com&quot;&gt; &lt;/p&gt;

&lt;p&gt;保存运行，试一下这段代码是否有错误：
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_4.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;将字节码文件（.class）转化成dex文件，命令为：&lt;br&gt;
&lt;cmd&gt;
$ dx --dex --output=classes.dex HelloWorld.class
&lt;/cmd&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_5.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;再将dex文件反编译成 smali文件，命令为：&lt;br&gt;
&lt;cmd&gt;
$ java -jar baksmali.jar -o aaa/ classes.dex
&lt;/cmd&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_6.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;去样本中将isInstallation反编译的代码结果覆盖到 aaa/HelloWorld.smali 的相应代码中：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_7.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;保存退出后，将这个smali代码编译为dex文件,命令为：&lt;br&gt;
&lt;cmd&gt;
$ java -jar smali.jar -o classes.dex  aaa/HelloWorld.smali
&lt;/cmd&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_8.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;此时将生成的dex文件上传到手机等待调用。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_9.png&quot; alt=&quot;rootkiter.com&quot;&gt;&lt;br&gt;
最后将要解密的字符串传到这个程序中就能解密对应字符串了，命令如下所示：&lt;br&gt;
&lt;cmd&gt;
# dalvikvm -cp /data/local/HelloWorld.zip HelloWorld Q=6/pbCypY64tfHs8UFBpZfETzsr
&lt;/cmd&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_08_20_00/2_10.png&quot; alt=&quot;rootkiter.com&quot;&gt;  &lt;/p&gt;

&lt;p&gt;这时输出的 “contact_id = ” 就是 ”Q=6/pbCypY64tfHs8UFBpZfETzsr” 这个字符串解密的结果了。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>SSH-Socks-Tunnel</title>
        <link href="http://rootkiter.com/2015/05/03/SSH_SOCKS_TUNNEL.html"/>
	<updated>2015-05-03T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/05/03/SSH_SOCKS_TUNNEL</id>
	<content type="html">&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;SSH是Secure Shell的缩写，常见于linux主机远程管理中，它和telnet之间有一定的联系，区别在于它的网络传输数据是经过加密的，而telnet是明文传输的，如果被抓包程序抓到，可能导致敏感信息泄漏的问题。&lt;br&gt;
那么SSH和Socks之间又有什么关系呢，看过&lt;a href=&quot;/2015/05/01/%E4%BD%BF%E7%94%A8Socks%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html&quot; title=&quot;Socks代理&quot;&gt;这篇文章&lt;/a&gt;一定会知道 Socks服务在网络管理中有很非常多的优点，除可隐身访问目标服务器外，还可以达到一种翻墙的效果。如果能让SSH服务器快速变成一个Socks代理服务器，对我们会有很多的益处（翻墙／远程内网渗透测试）。可能SSH的开发者也思考过这个问题，于是让SSH服务天生的就支持了Socks代理的功能，看来SSH还是挺可爱的嘛。&lt;/p&gt;

&lt;h1&gt;Windows客户端中部署Socks代理&lt;/h1&gt;

&lt;p&gt;在windows主机上利用ssh隧道的方法有很多，我这里用到的工具为Xshell。其使用步骤如下。&lt;br&gt;
1.配置Xshell，并通过ssh连接远程主机（测试中的ssh服务器为一台位于美国的私人VPS），如下图示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015_05_03_16_36/2_1.png&quot; alt=&quot;图1&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/images/2015_05_03_16_36/2_2.png&quot; alt=&quot;图2&quot;&gt;  &lt;/p&gt;

&lt;p&gt;2.在 文件－&amp;gt; 属性 菜单配置 socks代理的隧道  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015_05_03_16_36/2_3.png&quot; alt=&quot;图3&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/images/2015_05_03_16_36/2_4.png&quot; alt=&quot;图4&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/images/2015_05_03_16_36/2_5.png&quot; alt=&quot;图5&quot;&gt;&lt;br&gt;
&lt;img src=&quot;/images/2015_05_03_16_36/2_6.png&quot; alt=&quot;图6&quot;&gt;  &lt;/p&gt;

&lt;p&gt;此时本地的 127.0.0.1:1080 端口便有了一个刚配置好的Socks代理服务器，它将以SSH服务器为跳板来处理代理请求。&lt;br&gt;
有了代理服务后怎么用可参考&lt;a href=&quot;/2015/05/01/%E4%BD%BF%E7%94%A8Socks%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html&quot; title=&quot;Socks代理&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;Linux 客户端中部署Socks代理&lt;/h1&gt;

&lt;p&gt;由于测试环境限制，这里以Ubuntu环境为例其他的 *nux 主机方法类似：
利用 ssh 的 –D 选项可以在本地开启一个监听1080端口的 socks代理服务器。于此同时还能成功连接到远程的主机，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015_05_03_16_36/2_7.png&quot; alt=&quot;图7&quot;&gt;  &lt;/p&gt;

&lt;p&gt;代理的使用，依然可参考&lt;a href=&quot;/2015/05/01/%E4%BD%BF%E7%94%A8Socks%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html&quot; title=&quot;Socks代理&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>使用Socks代理服务</title>
        <link href="http://rootkiter.com/2015/05/01/%E4%BD%BF%E7%94%A8Socks%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html"/>
	<updated>2015-05-01T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/05/01/使用Socks代理服务</id>
	<content type="html">&lt;h1&gt;Socks代理服务介绍&lt;/h1&gt;

&lt;p&gt;Socks代理的工作原理可以通过一张时序图来直观展示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;从上图可以发现以下几点关键信息：&lt;br&gt;
1. 对于访问目标来说所有的交互都只和 Socks-server 有关，Client的身份被隐藏起来了。&lt;br&gt;
2. 当Client和访问目标间无法直接通讯时，Socks-server仍然可以正常工作，这同时又是一种翻墙操作。下面是一张描述该环境的示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;h1&gt;Socks代理服务的使用&lt;/h1&gt;

&lt;h2&gt;在浏览器中使用Socks代理&lt;/h2&gt;

&lt;p&gt;这里以FireFox为例，其它浏览器均有类似功能，配置方法大家可以自行Google搜索。&lt;br&gt;
在  菜单 -&amp;gt; 选项 -&amp;gt; 高级 -&amp;gt; 网络 -&amp;gt; 设置&lt;br&gt;
中可以配置代理，如下图所示(代理服务器为个人的一台国外主机)：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;p&gt;点击确定后，代理便生效了，下面通过访问 www.ip138.com 对比下代理前后的区别，如下所示：&lt;br&gt;
&lt;strong&gt;&lt;em&gt;代理前：&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_1_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;代理后：&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_1_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h2&gt;全局代理的配置&lt;/h2&gt;

&lt;p&gt;ProxyCap是一个可以设置全局代理的工具，它可以将主机大部分对外请求以代理方式发出，当某个工具无法配置代理时，这是一个不错的选择，使用方法如下：&lt;br&gt;
配置代理地址：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;p&gt;添加代理规则：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;p&gt;此时代理规则建立成功，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;p&gt;用浏览器访问 www.ip138.com 测试代理结果，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;h2&gt;代理协议的转化&lt;/h2&gt;

&lt;p&gt;在实际使用中，ssh工具可以创建socks代理，然而总有一些工具只支持http代理，这时需要将socks代理转化为http代理方可。此处可以用 Privoxy 工具达到这一效果。&lt;/p&gt;

&lt;p&gt;1.安装并运行Privoxy，通过 Options -&amp;gt; Edit Main Configuration 打开该工具的配置文件。随意哪里插入如下两行：&lt;br&gt;
&lt;code&gt;
listen-address  127.0.0.1:8118&lt;br&gt;
forward-socks5   /               127.0.0.1:1080  .&lt;br&gt;
&lt;/code&gt;
&lt;em&gt;PS ：forward 行尾有个点字符，缺失这个字符有时会导致代理失败。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这两行的意思是，将本地的 1080 端口监听的socks5协议转化为 8118端口的http代理协议。
保存退出该配置文件后，通过双次选择 Options -&amp;gt; Enable 选项，重启代理服务。&lt;/p&gt;

&lt;p&gt;2.最后，在FireFox 浏览器中配置代理协议为http，代理端口为本地 8118 端口，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;p&gt;3.此时访问 www.ip138.com 网站测试代理结果，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_05_01_16_33/3_3_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;   &lt;/p&gt;

&lt;h1&gt;写在最后&lt;/h1&gt;

&lt;p&gt;本文介绍了一些和socks代理使用相关的知识。文中提到的工具都有其它替代工具，感兴趣的可以自行挖掘新工具的用法。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>端口转发和SOCKS代理</title>
        <link href="http://rootkiter.com/2015/04/28/LCX_SOCKS.html"/>
	<updated>2015-04-28T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/28/LCX_SOCKS</id>
	<content type="html">&lt;h1&gt;起因&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&quot;http://rootkiter.com/EarthWorm/&quot; title=&quot;EarthWorm&quot;&gt;蚯蚓&lt;/a&gt;构思之初，我在网上集中搜集过socks代理的知识，发现网上的很多资料都把 &amp;quot;Socks代理&amp;quot;和&amp;quot;socket端口转发&amp;quot;混为一谈。于是我决定写这样一篇文章，来辨析一下它们之间的异同。&lt;/p&gt;

&lt;h2&gt;Socket端口转发&lt;/h2&gt;

&lt;p&gt;lcx.exe 就是一个基于 socket 套接字实现的端口转发工具，它是从 linux 下的htran 工具移植到windows平台的。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_28_22_13/2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;一条正常的socket隧道必具备两端，一侧为服务端，它会监听一个端口等待客户端连接；&lt;br&gt;
另一侧为客户端，通过传入服务端的ip和端口，才能主动连接到服务器。  &lt;/p&gt;

&lt;p&gt;而端口转发工具（lcx.exe/htran)的工作原理其实是将两条 socket 隧道对接起来，打造一条可“异步双向通讯”的转接隧道。由于合法的socket隧道有两种接口分别对应服务端和客户端，根据数学中的排列组合可计算出端口转发供具有4种工作状态，它们是：&lt;br&gt;
&lt;code&gt;
1.“客户端” 接 “客户端”&lt;br&gt;
2.“客户端” 接 “服务端”&lt;br&gt;
3.“服务端” 接 “客户端”&lt;br&gt;
4.“服务端” 接 “服务端”&lt;br&gt;
&lt;/code&gt;
又由于端口转发为“异步双向通讯”隧道，隧道转接不分先后，所以状态2和状态3 是相同的，合并之后，便分别对应了lcx的三种工作模式，如下所示：&lt;br&gt;
&lt;code&gt;
1、slave    “客户端” 接 “客户端”&lt;br&gt;
2、tran     “服务端” 接 “客户端”&lt;br&gt;
3、listen    “服务端” 接 “服务端”&lt;br&gt;
&lt;/code&gt;
于是便可理解lcx工具的三种命令参数的格式为何是以下的样子了：&lt;br&gt;
&lt;code&gt;
–listen  ConnectPort  TransmitPort&lt;br&gt;
–tran   ConnectPort  TransmitHost  TransmitPort&lt;br&gt;
–slave  ConnectHost  ConnectPort  TransmitHost  TransmitPort&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Socks代理&lt;/h2&gt;

&lt;p&gt;Socks 代理从名字中的“代理”二字就可以了解它的功能核心：那就是帮他人完成socket访问网络。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_28_22_13/2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;有过翻墙经历的同学大概知道浏览器（IE／Chrome／FireFox等）有设置socks代理的配置项，可用来访问网络的能力。当我们通过代理服务器访问一个网址时，socks服务器其实是起到了一个中间人的身份，他分别与两方（浏览器／被访问的网站）通讯然后将获取到的结果告知另一方。&lt;br&gt;
在使用代理服务的过程中我们会发现，只要配置好socks代理后，就不再需要指定被访问目标，直接在浏览器的地址栏输入地址就能访问任意网站。这是由于socks代理中有一个交互协议，当我们准备访问一个网站并敲击回车时，浏览器会先发送一个被访问目标的基本信息（URL和服务端口）给socks服务端，socks服务端解析了这个信息后，会代替浏览器去访问目标网站，并将访问结果回复给浏览器端。这便是socks代理的工作原理了。&lt;br&gt;
通过这段对socks代理的描述，可知socks代理其实可理解为一个增强版的 lcx -tran 它在服务端监听一个服务端口（ConnectPort），当有新的连接请求时会从socks协议中解析出访问目标的URL（TransmitHost）的目标端口(TransmitPort)，再开始执行lcx -tran 的具体功能。  &lt;/p&gt;

&lt;h2&gt;两者的异同&lt;/h2&gt;

&lt;p&gt;1.socket端口转发无需通讯协议支持，而socks代理需要socks协议支持。&lt;br&gt;
2.socket端口转发有三种工作方式，而socks代理仅有一种工作方式。&lt;br&gt;
3.如果说socks是帮他人访问网络（一对多），那么端口转发就是帮他人访问主机的某个端口（一对一）。&lt;/p&gt;

&lt;h1&gt;一句话总结：&lt;/h1&gt;

&lt;p&gt;这篇笔记从“socket端口转发”和 “socks代理” 两者的工作原理出发，介绍了两者的区别。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>构造ROP</title>
        <link href="http://rootkiter.com/2015/04/24/MAKE_ROP.html"/>
	<updated>2015-04-24T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/24/MAKE_ROP</id>
	<content type="html">&lt;p&gt;构造一个可用的ROP可以分7步来操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;确定目标&lt;br&gt;&lt;/li&gt;
&lt;li&gt;针对目标实现步骤，确定需要的ROP样式&lt;br&gt;&lt;/li&gt;
&lt;li&gt;搜索模块中可用代码片段。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;封装代码片段至模块&lt;br&gt;&lt;/li&gt;
&lt;li&gt;书写简单的ROP伪指令&lt;br&gt;&lt;/li&gt;
&lt;li&gt;组装代码片段&lt;br&gt;&lt;/li&gt;
&lt;li&gt;调试完成&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;一、确定目标：&lt;/h3&gt;

&lt;p&gt;无论做什么都需要有明确的目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;已知一信息泄漏漏洞（MS13-037）可泄漏 ntdll 的基地址 @ntdll_base;&lt;/li&gt;
&lt;li&gt;被攻击目标为 WIN7_x86 ＋ IE8 ，且 ntdll 版本号为 6.1.7601.17514。&lt;/li&gt;
&lt;li&gt;有一任意代码执行漏洞（任意 EIP 可控漏洞均可）&lt;/li&gt;
&lt;li&gt;求一可用的 metasploit 的漏洞利用模块。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过阅读&lt;a href=&quot;/2014/02/28/ROPIntroduce.html&quot; title=&quot;ROP介绍&quot;&gt;第一篇笔记&lt;/a&gt;可以得知：调用ZwProtectVirtualMemory（）可以完成关闭DEP的操作，而调用之前需要将栈状态布置为下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;此时通过RETN指令调用Zw*函数后才能将shellcode所在区域开DEP保护。所以我们的目标就是构造这样一片的堆栈结构。&lt;/p&gt;

&lt;h3&gt;二、针对目标实现步骤，确定需要的ROP样式&lt;/h3&gt;

&lt;p&gt;观察目标堆栈结构可以发现，构造这样的堆栈存在以下几点困难：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
1.ShellCode 地址由于是动态分配到堆内存中，无法固定&lt;br&gt;
2.0x00000040   和 0x0000 0400 两个数据存在格式为%u0000的unicode坏字符，无法直接部署。
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是，这种栈状态存在7个双字需要在ROP中动态设置(参照上图带红点的位置)。这可能会用到以下种类的ROP代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
1.MOV [ reg ], reg&lt;br&gt;
//布置堆栈，操作内存，当然需要写内存指令了&lt;br&gt;
2.ADD（SUB） reg,reg&lt;br&gt;
//计算shellcode -0c、shellcode-04这种地址的值&lt;br&gt;
//计算MOV [reg],reg 指令中  [reg] 的值&lt;br&gt;
3.MOV  reg，ESP&lt;br&gt;
//这条指令是最重要的，没有它，根本无法动态定位shellcode地址&lt;br&gt;
4.NOT reg&lt;br&gt;
//这条指令可有可没有，用来计算0x00000040 和 0x00000400 这种值，如果没有的话，通过Add（SUB） 指令也能实现&lt;br&gt;
5.POP reg&lt;br&gt;
//这条指令可用于向寄存器赋值，是寄存器计算前的必要指令。&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这些种指令中，实际查找时会发现除第五条指令外，其他格式的指令均难以寻找。我也是找了一个星期才凑全这5种指令格式。&lt;/p&gt;

&lt;h3&gt;三、搜索模块中可用代码片段&lt;/h3&gt;

&lt;p&gt;搜索过程中搜到了很多和最终构造无关但可能有奇效的指令，详情可参考&lt;a href=&quot;/2015/04/23/GOLD_IN_THE_NTDLL.html&quot; title=&quot;NTDLL空间&quot;&gt;第二篇笔记&lt;/a&gt;。&lt;br&gt;
1. MOV [ reg ], reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要 12个字节的垃圾填充。&lt;br&gt;
2. SUB reg,reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要 8个字节的垃圾填充。&lt;br&gt;
3. MOV reg,ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
无需字节填充，但需要在pushad发生前构造各相关寄存器值。&lt;br&gt;
4. NOT reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
需要16字节垃圾填充&lt;br&gt;
5. POP reg&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_7.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_3_8.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;四、封装代码片段至模块&lt;/h3&gt;

&lt;p&gt;为了后期使用的方便，最好能够将个代码片段封装成ROP片段，最终ROP_chain构造时直接拷贝粘贴即可。各个指令片段封装格式如下所示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
MOV [ ecx ], eax&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
SUB  eax,edx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
MOV  ecx，ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
MOV  eax, ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
NOT eax&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
POP ecx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
POP edx&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_4_8.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;五、书写简单的ROP伪指令&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_5_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;p&gt;这段ROP片段 ＋ Zw* ＋ “调用栈结构” + Shellcode，就可以成功关闭DEP并运行后侧的 shellcode 了。 
然而在这段伪指令中发现，每次写地址需要计算两次，如果都用SUB实现，将会经常备份数据，因为eax只有一个，组织代码将会相当复杂，如果能找到其他的加法指令就会好多了。
带着这个问题，我在内存中又简单的搜索了一下，顺利找到了以下代码：
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_5_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这处代码原本是INC ECX \  RETN 如果连续使用4次，正好能够完成ADD ecx，4的功能。至此“万事具备，只欠拼接”。&lt;/p&gt;

&lt;h3&gt;六、组装代码片段&lt;/h3&gt;

&lt;p&gt;这个没什么好说的了，就是参照伪代码，把封装好的代码片段组合到一起，如下图所示：
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_6_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;七、调试完成&lt;/h3&gt;

&lt;p&gt;在metasploit中启动运行，用IE8+Win7访问，查看是否能够成功执行shellcode，如果访问失败，可以通过设置c3断点，或在ROP中设置0x41414141进行中断，另外SUB指令执行时的EDX值，既可以在构造完成后集中计算，也可以单步跟踪时手动调节。&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_7_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_24_20_33/2_7_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h1&gt;结尾：&lt;/h1&gt;

&lt;p&gt;本篇笔记记录了一个相对复杂的ROP构造过程。&lt;/p&gt;

&lt;p&gt;ROP构造是一个奇妙的过程，它和程序设计有着很多相似之处，都是需要先明确目标，然后选择伪代码描述，最终用代码组织完成。然而和普通程序设计不同的是，ROP的语法块需要在内存中去寻找，并自己定义，只有找全了各种功能的代码片段，才能完成最终的ROP_chain编写。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ntdll 空间中的金疙瘩</title>
        <link href="http://rootkiter.com/2015/04/23/GOLD_IN_THE_NTDLL.html"/>
	<updated>2015-04-23T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/23/GOLD_IN_THE_NTDLL</id>
	<content type="html">&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;通过阅读&lt;a href=&quot;/2014/02/28/ROPIntroduce.html&quot; title=&quot;ROP介绍&quot;&gt;第一篇笔记&lt;/a&gt;，可以知道，ROP构造是软件类漏洞利用中很重要的一环(为了绕过dep保护)，然而用过mona工具的童鞋应该都清楚，这个工具似乎不太好用。即使你通过mona搞定了ROP骨架的生成，有时仍然需要微调，特别是当mona结果中拥有和漏洞环境相关的坏字符时，修复ROP-chain 也成为了软件类漏洞利用的重要一环。&lt;/p&gt;

&lt;p&gt;此时这篇笔记的意义就出现了：&lt;strong&gt;&lt;em&gt;如何找到有用的ROP素材，并将存在问题的ROP-chain修复。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文中提到的代码素材均来自于ntdll.dll文件，其中&lt;br&gt;
&lt;code&gt;
ntdll.dll版本号为：6.1.7601.17514&lt;br&gt;
本机Win7 启动后ntdll的偏移： 0x77880000
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;声明：&lt;br&gt;
不同版本，得到的代码偏移可能不同。&lt;br&gt;
至于DLL模块基地址嘛。。。那是一定不同滴。。。因为我是在Win7环境下查找的指令，看客可以通过搜索特定指令序列，或通过我给出的偏移计算出来。&lt;br&gt;
本段将纪录，我在 ntdll.dll 中找到的各种指令，它们可以用来做四则运算，甚至用来处理内存拷贝。&lt;/p&gt;

&lt;h1&gt;有趣的代码片段&lt;/h1&gt;

&lt;h2&gt;XCHG系列&lt;/h2&gt;

&lt;p&gt;这个系列的指令，在ROP构造中有奇效。ROP-chain中每个寄存器中的值都是宝贝，遗失不得。而在执行 xchg 指令时，完全不会干扰到其他寄存器的内容，他们之间真的非常般配。&lt;/p&gt;

&lt;h3&gt;xchg eax,esp&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是 IE 漏洞利用中经常用到的一条控制ESP的指令。它在漏洞触发的那一刻能够将ESP从“栈指针”，改成“堆指针”，配合“堆喷射”技术完成漏洞利用。&lt;/p&gt;

&lt;h3&gt;xchg eax,edx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是一条可用来保存 eax 的指令。由于多数汇编指令都会用到eax寄存器，这条指令刚好能把当前寄存器中的数据同 edx 交换一下，用起来很方便。&lt;/p&gt;

&lt;h3&gt;xchg eax,ecx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_1_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;当我想把 ECX 作为内存指针时，完全可以通过 EAX 计算出相应地址，然后放到交换到ECX中。&lt;/p&gt;

&lt;h2&gt;add 系列&lt;/h2&gt;

&lt;h3&gt;sub eax,edx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;看到这里不明真相的群众一定会问，这明明是 sub指令，为毛划分到 add系列 中呢？&lt;br&gt;
这是因为 sub指令 比 add指令 有效得多，如果使用ADD指令执行 eax +0x20 的操作，得到的ROP素材应该是这样的：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EDX # RETN }&lt;br&gt;
0x00000020&lt;br&gt;
Address -&amp;gt; { ADD EAX,EDX …… }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时，这样的ROP-chain中出现了一个坏字符%u0000％u2000，这个坏字符将会非常难以去除。然而如果用 sub 指令，就可以是这样的：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EDX # RETN }&lt;br&gt;
0xffffffe0&lt;br&gt;
Address -&amp;gt; { SUB EAX,EDX …… }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;坏字符被巧妙的避开了，减去一个负数 等同于 加上一个正数，初中数学绝对不白学。&lt;/p&gt;

&lt;h3&gt;inc xxx&lt;/h3&gt;

&lt;h4&gt;inc ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令，我是找了很久才发现的。它出现的时候，我真的眼前一亮，它意味着，我可以不用EAX来做简单的加法运算了，当我仅需要给一个数字 +4 时，我只要写四次这个地址就好了。&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
Address -&amp;gt; { INC ECX ,RETN  }&lt;br&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这可以节省我很多 备份数字的操作，更棒的地方在于 retn 指令没有参数，完全不需要垃圾字符填充。绝对是一条高效的 rop 指令素材。&lt;/p&gt;

&lt;h4&gt;inc eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个指令素材，有两种功效，当我需要向EAX写入1时，我可以使用三条指令，ROP示例如下：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { XOR EAX,EAX # INC EAX # RETN }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而当我仅需要将 EAX + 1 时，我可以使用：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { INC EAX # RETN  }
&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;inc ebx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令应该不用说了，和前面的 inc ecx 有相似之处。&lt;/p&gt;

&lt;h4&gt;inc edx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_2_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3&gt;其他运算&lt;/h3&gt;

&lt;h4&gt;xor eax,ecx&lt;/h4&gt;

&lt;p&gt;xor系列指令貌似都比较少，也都不够高效，需要填充很多垃圾字符：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;它的使用大概是这样的：&lt;br&gt;
&lt;code&gt;
Address  -&amp;gt; { XOR EAX,ECX # POP ESI # POP EBP # RETN 8  }
0x41414141   // skip 4 for pop esi&lt;br&gt;
0x41414141   // skip 4 for pop esi&lt;br&gt;
Address  -&amp;gt; { 下一条指令 }
0x41414141   //skip  4 for retn 8
0x41414141   //skip  4 for retn 8
&lt;/code&gt;  &lt;/p&gt;

&lt;p&gt;这条指令还是可以用来处理一些通常情况无法绕过的垃圾字符滴。&lt;/p&gt;

&lt;h4&gt;xor eax,edx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;使用方法参照 xor eax,ecx ,不过看起来似乎比那条指令更好用一些，垃圾字符填充也会少一些。&lt;/p&gt;

&lt;h4&gt;idiv ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_3_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是一个有趣的素材，它能计算除法，因为除法对寄存器的干扰实在太明显了，所以在ROP中用处也不会太大。但有一条就比没有强，没准会遇到什么样子的奇葩环境。&lt;/p&gt;

&lt;h4&gt;not eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_3_4_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;/p&gt;

&lt;p&gt;这条指令，是偶然发现的，并运用到了一次ROP构造中，非常好用，很可惜的是过于浪费空间，一句 RETN 0C 就要浪费 3个DWORD。使用方法大致如下：&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EAX # RETN}
Address -&amp;gt; { NOT EAX # POP EBP # RETN 0C }
0x41414141     // skip 4  for pop ebp
Address -&amp;gt; { 下一条指令 }
0x41414141     // skip 4  for  retn0c
0x41414141     // skip 4  for  retn0c
0x41414141     // skip 4  for  retn0c
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;赋值系列指令&lt;/h2&gt;

&lt;h3&gt;POP XXX&lt;/h3&gt;

&lt;p&gt;这系列指令大概不用讲了，都清楚，当你需要执行 MOV EAX，0x43434343 时，
直接用&lt;br&gt;
&lt;code&gt;
Address -&amp;gt; { POP EAX # RETN }
0x43434343
&lt;/code&gt;&lt;br&gt;
即可。
对应的4个寄存器的pop指令素材为：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_1_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h3&gt;寄存器间传值&lt;/h3&gt;

&lt;h4&gt;mov eXX,eXX&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_1_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_1_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;  &lt;/p&gt;

&lt;h4&gt;pushad&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_1.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
请， 先收起你的惊讶的表情... pushad 确实可以进行寄存器间赋值～～～
当你想动态定位shellcode位置时，可能会需要这样一条指令，MOV EAX，ESP，然而你找遍内存也可能搜索不到可用的素材，怎么办呢？这时，你就可以通过 PUSHAD RETN 来构造一条这样的指令。PUSHAD后堆栈的状态是这样的（如下图所示），此时再调用retn其实将会返回到EDI所指向的指令，如下图所示：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_2.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
那么我只要让堆栈中是下面这种结构，就可以把ESP的值赋值给EAX了：&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
也就是说，调用PUSHAD前，你可以通过POP EDI、POP EBP、POP EBX、POP ECX等指令，部署各个寄存器所指向的地址，这样在调用PUSHAD RETN之后便可实现任意寄存器间的赋值了。下面是我在一次ROP构造时构造的 MOV ECX，ESP&lt;br&gt;
&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这条指令很 cool 吧。
其实这条指令还可以在 PUSHAD 的 RETN 后，跳到某个API函数的地址，只要控制好各个寄存器的值，绝对能让人神清气爽！&lt;/p&gt;

&lt;h4&gt;5POP指令&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_3.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
我把这条指令放在这个位置，是想说明：5POP指令和PUSHAD可以很奇妙的组合在一起，当你在PUSHAD指令前将EBP指向 5POP，那么你就能非常快速的跳出 PUSHAD 对堆栈造成的影响，顺利回到ROP_chain的空间，5POP指令同样也可以拆分使用，甚至可以在一句话完成多个MOV操作，因为这条指令中同时有POP ECX 和POP EBX两条指令。&lt;/p&gt;

&lt;h4&gt;xchg eax，edx？&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_4.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这段指令共有4条，全部组合在一起，就是一个通过 ecx 寄存器实现XCHG EAX，EDX，而当你使用其中的三条时，指令就变成了 MOV 【EAX：EDX】，【EDX：ECX】或者用其中的两条就变成了 MOV EDX，ECX。&lt;/p&gt;

&lt;h4&gt;mov [ecx],eax&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_5.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这条指令可以实现向 ecx 指向的空间写入一个双字数据，功能很棒，当你无法通过常规方式（ROP的堆栈中存在坏字符）控制堆栈数据时，你同样可以通过这样一条指令完成前方堆栈数据的配置，以及API调用前堆栈的部署。&lt;/p&gt;

&lt;h4&gt;mov [edx],ecx&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/images/2015_04_23_21_33/2_4_2_6.png&quot; alt=&quot;图片丢失，请联系作者&quot;&gt;&lt;br&gt;
这片指令，也能起到写内存的作用，如果你有足够的闲心，再配合上 inc edx 这种指令进行内存计算，一定能把一整段shellcode写到一个可执行的内存片中。&lt;/p&gt;

&lt;h2&gt;回顾&lt;/h2&gt;

&lt;p&gt;本文介绍了ntdll中的一些有趣的指令素材，旨在扩充人们对于ROP指令素材的认识，很多人认为ROP素材能做的事情非常有限，通过这篇文章相信你就能很清楚的意识到，ROP指令也可以很艺术，其实我一直相信某些特殊组合的ROP指令素材同样也能具备“图灵完备”性质。当然了，这需要有足够的创造性能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS: 这是我两年之前写的一篇笔记，现在看这些文字，已经成为了上个世纪的东西。漏洞利用（软件类）的攻防也上升到了一个全新的阶段。现阶段软件漏洞利用让人感觉门槛更高了，DVE技术也开始要求利用者对脚本语言的JIT形态有一定了解，希望在掌握更多基础知识之后，回过头来能追上大牛们的步伐吧。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
</entry>

<entry>
	<title>关于博客</title>
        <link href="http://rootkiter.com/2015/04/06/AboutBlog.html"/>
	<updated>2015-04-06T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2015/04/06/AboutBlog</id>
	<content type="html">&lt;p&gt;距离上一篇文章已经过去了一年，这期间一直没想好如何来定位这个博客。&lt;/p&gt;

&lt;p&gt;前段时间把蚯蚓的主页弄起来，才想起是时候重新构思这个博客了。&lt;/p&gt;

&lt;p&gt;现在的我，开始决定不为了写博客而写博客，而是有选择性的写，挑有趣的东西来写，题材也不仅仅局限于技术，读过的书，追过的美剧，只要我觉得有趣，我就准备写在这里，Just For Fun，希望 linus 教主不会怪我乱用他老人家的名言。:-P &lt;/p&gt;

&lt;p&gt;为了保证质量，不准备追求更新时间。只要写了一篇就总有下一篇。&lt;/p&gt;

&lt;p&gt;看来这里将有机会，成为有史以来最不靠谱的博客了，YO-HO-HO-HO~~~。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>ROP Introduce</title>
        <link href="http://rootkiter.com/2014/02/28/ROPIntroduce.html"/>
	<updated>2014-02-28T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2014/02/28/ROPIntroduce</id>
	<content type="html">&lt;h2&gt;背景介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DEP保护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DEP 保护是缓冲区溢出攻击出现后，出现的一种防护机制，
它的核心思想就是将内存分块后，设置不同的保护标志，
令表示代码的区块拥有执行权限，而保存数据的区块仅有
读写权限，进而控制数据区域内的shellcode无法执行。&lt;/p&gt;

&lt;p&gt;下面的两幅图分别表示了数据区域内“不可执行”和“
可执行”的状态：
&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-1.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-2.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;DEP的实现分为两种，一种为软件实现，是由各个操作系统
编译过程中引入的，在微软中叫SafeSEH。 另一种为硬件
实现，由 英特尔这种CPU硬件生产厂商固化到硬件中的，
也称作NX保护机制。&lt;/p&gt;

&lt;p&gt;单从DEP的定义可以发现，这种机制应该是能够有效抑制数据
区域内shellcode执行的。此时攻击者的面前出现了一座难以
逾越的山。&lt;/p&gt;

&lt;p&gt;要想知道如何绕过这种保护机制，请详细阅读本文下面的部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ret-to-lib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DEP 保护机制出现后，攻击者几乎无法令数据段中的shellcode
直接执行，看起来“防御技术”此时占得了先机。&lt;/p&gt;

&lt;p&gt;这里插一句题外话：我觉得 Hacker 永远是这个世界上
最聪明的一群人，它们总能发现一些常人无法发现的东西。&lt;/p&gt;

&lt;p&gt;Hacker中此时出现了一位天才，他开始教育大家，既然数据区
域没有执行状态那我们就让他们只保存数据吧，反正地址也是
数据的一部分，而内存中有还有无尽的代码供我们使用，只要
我们能把某些有趣的代码片段按照一定思路拼接起来，那么数
据区域是否可执行完全和漏洞利用就完全没有关系了。&lt;/p&gt;

&lt;p&gt;下面我将开始详细阐述这位“天才 Hacker” 的“天才想法”：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;一方面&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;汇编语言中有一系列非常有用的指令，我管它们叫做“RETN系列指
令”，这些指令的原始功能是当函数调用完成时，回退到上一层调
用函数，并继续下面的执行，示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-3.png&quot; title=&quot;ropimage/ROP1-3.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另一方面&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这种DEP的保护机制，虽然安全，却令操作系统在做某些操作时受到限制，所以操作系统中又提供了一些解除DEP保护的API供软件开发人员调用，当攻击者在内存中定位到这些API并调用时，DEP保护便失去作用了。这些API一直散落于内存的某些角落，当攻击者触发它们时，就好像触发了某个密室的暗门一样，豁然开朗。&lt;/p&gt;

&lt;p&gt;当RETN指令同这些API联系在一起时，就会产生一些奇妙的化学反应，首先看一下原本缓冲区溢出的攻击模式：&lt;/p&gt;

&lt;p&gt;&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-4.png&quot; title=&quot;ropimage/ROP1-4.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;有了DEP后的间接利用攻击的示意图：
&lt;img 
src=&quot;http://rootkiter.com/image/ropimage/ROP1-5.png&quot; title=&quot;ropimage/ROP1-5.png&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以看到在第二种模式下，EIP的控制是通过栈中的地址，以及代码中的RETN指令共同控制的，此时栈中的数据仍然是“数据”，而执行位置却转移到了内存的代码空间，如此下来便巧妙的绕过了DEP保护。&lt;/p&gt;

&lt;p&gt;那么这种绕过技术其实是基于一个特定条件的，那就是你到某个地址一定能找到对应的包含RETN的代码片段，可以说这是当前漏洞利用方式的薄弱环节。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ASLR保护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过前面的阅读，大家可能已经了解，DEP机制的弱点就是可以通过某些API调用进行关闭，进而令其失效，然而令Hacker叫绝的是，这些API的地址完全固定，只要控制好栈结构，依然可以令shellcode得到执行。于是安全人员又提出了“ASLR机制”辅助DEP，提升系统安全性。&lt;/p&gt;

&lt;p&gt;ASLR是一种内存地址随机化技术，它的核心思路是让程序执行时所调用的外部模块地址完全随机化，这种随机化令关闭DEP保护的API也随着飘忽不定，在WIN7中它的存在并不明显，而在WIN8中该技术得到了长足的发展。&lt;/p&gt;

&lt;p&gt;WIN7中的实现是每次系统启动，模块地址随机，而启动完成后，到关闭之前，这个地址一般都不会改变。然而WIN8中，每两次程序运行，加载的模块地址都会随机起来。这种随机地址带来的安全效果非常明显，攻击者几乎没有办法利用原有攻击手段完成漏洞利用（地址随机导致无法找到关闭DEP的地址，而无法关闭DEP就无法令数据块中的shellcode得到执行），所以安全人员经常戏称“ASLR+DEP”为“海尔兄弟”，下面是WIN7中启用ASLR后，ntdll在两次电脑开启时的地址：&lt;/p&gt;

&lt;p&gt;可以看到这次电脑启动 ntdll.dll模块的位置为 0x77880000
&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-6.png&quot; aglin=&quot;center&quot;&gt;&lt;/p&gt;

&lt;p&gt;重启计算机后，这个模块的基地址变为0x77620000&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;从以上两幅截图可以看出，地址随机化带来的直观效果就是模块顺序同样发生了改变，这就如同把攻击者放到了一个内存密室中，暗门的位置随时在变化，攻击者想要找到暗门的难度无疑增大了许多。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ASLR机制出现之后，攻击者面临着另一个严俊的挑战（我想管这个挑战叫：太行山），“ASLR”也成了他们攻击技术提升的障碍，然而所谓“道高一尺，魔高一丈”，“防御技术”总是落后于“攻击技术”出现的。&lt;/p&gt;

&lt;p&gt;对于攻击者来说“关闭DEP的API”在某个模块中的偏移地址是固定的，所以内存漏洞利用的第一步就是找到模块基地址，随后根据偏移位置找到关闭DEP的API，而“信息泄露”类漏洞能够非常出色的完成这个基址定位的功能，所以可以看到WIN7之后很多漏洞的利用都是两个漏洞组合使用的（通过信息泄露类漏洞寻找dll文件基地址，随后计算API地址，最后在代码执行类漏洞中调用API完成“关闭DEP”的操作，关闭后跳转回shellcode进行实际攻击）。 以上这种攻击思路的前半段就是“现在人们传唱的ROP”了。.&lt;/p&gt;

&lt;p&gt;下面是metasploit中某个利用模块的ROP片段截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;关于以上图片的更多技术细节，请阅读本文下面的部分获得。&lt;/p&gt;

&lt;h2&gt;ROP构造方法&lt;/h2&gt;

&lt;p&gt;通过阅读相关文章，可以得知：在Windows中有多种绕过DEP的方式，可供ROP开发，包括但不限于以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Zw(Nt)SetInformationProcess()&lt;/li&gt;
&lt;li&gt;VirtualProtect()&lt;/li&gt;
&lt;li&gt;VirtualAlloc()&lt;/li&gt;
&lt;li&gt;Zw(Nt)ProtectVirtualMemory()&lt;/li&gt;
&lt;li&gt;利用可写可执行的内存空间绕过DEP&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中1、2、3、5四种绕过办法在《0Day安全（第二版）》中有详细的阐述，其中第一种在《Python灰帽子》中，还详细介绍了如何通过脚本快速实现ROP开发。那些文字都是出自真正的大牛之手,所以我就不多说了，本节将对第四种绕过方式做一定的阐述。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Zw(Nt)ProtectVirtualMemory()函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个函数位于ntdll模块中，有两个版本，分别是Zw* 和 Nt* ，分别对应用户态和内核态的调用实现，我个人觉得两者应该没有区别，不过鉴于当前各种EXP都是通过Zw&lt;em&gt;进行利用，我们也就没必要细究Nt&lt;/em&gt; 是否能够达到利用目的了，毕竟两者的构造环境完全相同，花费的精力也完全相同。&lt;/p&gt;

&lt;p&gt;在ROP章节的末尾我给出了一个ZwProtectVirtualMemory（）ROP的构造截图，图中的代码位于metasploit的MS13_037模块中，本意是借助HeapSpray（风水）技术控制内存，进行利用的，所以在实现过程中shellcode以及参数地址可以完全固定，为了分析的方便，我们直接观察触发后堆栈状态即可。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出以下3点：&lt;/p&gt;

&lt;p&gt;1.EIP目前指向的地址正好为 [ESP-4] 对应的地址0x778896c9，可以表明此时EIP正在受ESP控制阶段。且当前指令如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2.所指向的栈内的结构和1.4节给出的截图完全相同，为了方便观察，我将栈内的结构转换一下，方便大家对比：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;3.0x0c0c0c14是常见的HeapSpray（风水）技术的遗留结果，既HeapSpray发生之前，那个位置为ROP，那个位置为shellcode是完全可控的，此处无需考虑ASLR造成的影响。&lt;/p&gt;

&lt;p&gt;通过阅读ntdll_rop 中的注释可以确定栈内各数据的含义，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-12.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;把这张图用自然语言描述出来就是：在当前进程（ProcessHandler= -1）划分0x400大小的内存片段，起始地址为0x0c0c0c40，将这块内存的状态设置为0x000040，原始状态为0x41414141（这就是垃圾字符嘛，请无视），操作完成后跳转到0x0c0c0c40继续执行（1、指向ShellCode）。&lt;/p&gt;

&lt;p&gt;相信到达这里就能清楚这条ROP的实际效果了，将shellcode所在的内存区域设置为0x00000040，当我们执行完这条指令后，这段内存会变成如下图所示的状态：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-13.png&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用mona辅助构造ROP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前网络中流通的ROP大部分都出自mona这个脚本，他是Immunity Sec公司开发的一个python脚本，可以辅助安全人员完成ROP的开发，原脚本仅适用于Immunity Debugger，后期开发了适用Windbg调试器的环境，看官可以参照{&lt;a herf=&quot;http://redmine.corelan.be/projects/windbglib&quot;&gt;网址&lt;/a&gt;}进行配置。此处不浪费笔墨。&lt;/p&gt;

&lt;p&gt;通过[ .load pykd.pyd ] [ !py mona rop -m ntdll.dll ]两个命令，可以实现，指定模块的ROP生成，生成时间较长，本次针对ntdll模块的ROP生成共用了近4分钟（没办法，它是虚拟了一个执行环境，然后又由Windbg调用，脚本环境下虚拟执行脚本，能快就怪了），刚开始用时候若不是我去了一趟厕所，我还以为它死掉了呢：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;生成结果的一个片段如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.com/image/ropimage/ROP1-15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;Mona 一般会生成两段ROP，分别用3种格式展示：Ruby、Python、Javascript。似乎Mona生成的ROP都是针对VirtualProtect的，而且是从内存序列中提取该函数指针，所以在ASLR模式下并不完全适用，我推荐这个工具的原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它可以给你提供几个有效的ROP指令片段，以免你自己去找。&lt;/li&gt;
&lt;li&gt;它可以给你一个构造ROP的思路，当然目前来看这个思路也极不靠谱。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;有个黑阔展示过一个ROP生成工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我听过一个不负责任的传说，为了大家不找我或者谣言散播者打击报复，我就必须声明：该传闻极不负责任，请大家不要相信。&lt;/p&gt;

&lt;p&gt;这个传说是这样的：有个黑阔在BlackHat上演讲，自己历时2年，开发了一个工具，并吹嘘自己的工具可以找到很多其他工具无法挖掘到的ROP指令，然后又现场展示了一下ROP生成效果，据说效果良好- -！。并在演讲的最后宣布：该工具，闭源不放。馋死他人！！&lt;/p&gt;

&lt;h2&gt;回顾&lt;/h2&gt;

&lt;p&gt;本文起初回顾了一下ROP技术的前世今生，力求各位对二进制漏洞有兴趣的
人能够读懂。&lt;/p&gt;

&lt;p&gt;第二部分介绍了一种ROP指令的技术细节，以及生成方法。&lt;/p&gt;
</content>
</entry>

<entry>
	<title>第一篇 博客</title>
        <link href="http://rootkiter.com/2014/02/25/firstBlogTest.html"/>
	<updated>2014-02-25T00:00:00+08:00</updated>
	<id>http://rootkiter.rootkiter.com/2014/02/25/firstBlogTest</id>
	<content type="html">&lt;p&gt;&lt;em&gt;这里是普通的斜体字&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;这里可以使用 H2 的字体&lt;/h2&gt;

&lt;p&gt;这是本博客的第一篇正文，
用于检测当前的工作状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这是列表项1&lt;/li&gt; 
&lt;li&gt;这是列表项2&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;1*1&lt;/th&gt;
&lt;th&gt; =1&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;2*2&lt;/th&gt;
&lt;th&gt; =4&lt;/th&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;http://rootkiter.github.io/image/test.jpg&quot; title=&quot;图片测试&quot; align=&quot;center&quot;&gt;&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tuhaihe.com&quot;&gt;tuhaihe.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>

</feed>
