<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>使用Socks代理服务</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "http://hm.baidu.com/hm.js?23ca870ecf6126f172d4f8539b0a593a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">RootKiter</a></h1>
          </div>

          <h2>使用Socks代理服务
</h2>
<!--
<audio controls=true autoplay="true">
  <source src="http://rootkiter.rootkiter.com/music/">
</audio>
-->

<p class="meta">01 May 2015</p>

<div class="post">
<h1>Socks代理服务介绍</h1>

<p>Socks代理的工作原理可以通过一张时序图来直观展示：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/2_1.png" alt="图片丢失，请联系作者"></p>

<p>从上图可以发现以下几点关键信息：<br>
1. 对于访问目标来说所有的交互都只和 Socks-server 有关，Client的身份被隐藏起来了。<br>
2. 当Client和访问目标间无法直接通讯时，Socks-server仍然可以正常工作，这同时又是一种翻墙操作。下面是一张描述该环境的示意图：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/2_2.png" alt="图片丢失，请联系作者"></p>

<h1>Socks代理服务的使用</h1>

<h2>在浏览器中使用Socks代理</h2>

<p>这里以FireFox为例，其它浏览器均有类似功能，配置方法大家可以自行Google搜索。<br>
在  菜单 -&gt; 选项 -&gt; 高级 -&gt; 网络 -&gt; 设置<br>
中可以配置代理，如下图所示(代理服务器为个人的一台国外主机)：<br>
<img src="http://rootkiter.com/images/2015_05_01_16_33/3_1_1.png" alt="图片丢失，请联系作者">  </p>

<p>点击确定后，代理便生效了，下面通过访问 www.ip138.com 对比下代理前后的区别，如下所示：<br>
<strong><em>代理前：</em></strong>  </p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_1_2.png" alt="图片丢失，请联系作者">  </p>

<p><strong><em>代理后：</em></strong>  </p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_1_3.png" alt="图片丢失，请联系作者">  </p>

<h2>全局代理的配置</h2>

<p>ProxyCap是一个可以设置全局代理的工具，它可以将主机大部分对外请求以代理方式发出，当某个工具无法配置代理时，这是一个不错的选择，使用方法如下：<br>
配置代理地址：  </p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_2_1.png" alt="图片丢失，请联系作者">   </p>

<p>添加代理规则：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_2_2.png" alt="图片丢失，请联系作者">   </p>

<p>此时代理规则建立成功，如下图所示：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_2_3.png" alt="图片丢失，请联系作者">   </p>

<p>用浏览器访问 www.ip138.com 测试代理结果，如下图所示：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_2_4.png" alt="图片丢失，请联系作者">   </p>

<h2>代理协议的转化</h2>

<p>在实际使用中，ssh工具可以创建socks代理，然而总有一些工具只支持http代理，这时需要将socks代理转化为http代理方可。此处可以用 Privoxy 工具达到这一效果。</p>

<p>1.安装并运行Privoxy，通过 Options -&gt; Edit Main Configuration 打开该工具的配置文件。随意哪里插入如下两行：<br>
<code>
listen-address  127.0.0.1:8118<br>
forward-socks5   /               127.0.0.1:1080  .<br>
</code>
<em>PS ：forward 行尾有个点字符，缺失这个字符有时会导致代理失败。</em></p>

<p>这两行的意思是，将本地的 1080 端口监听的socks5协议转化为 8118端口的http代理协议。
保存退出该配置文件后，通过双次选择 Options -&gt; Enable 选项，重启代理服务。</p>

<p>2.最后，在FireFox 浏览器中配置代理协议为http，代理端口为本地 8118 端口，如下图所示：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_3_1.png" alt="图片丢失，请联系作者">   </p>

<p>3.此时访问 www.ip138.com 网站测试代理结果，如下图所示：</p>

<p><img src="http://rootkiter.com/images/2015_05_01_16_33/3_3_2.png" alt="图片丢失，请联系作者">   </p>

<h1>写在最后</h1>

<p>本文介绍了一些和socks代理使用相关的知识。文中提到的工具都有其它替代工具，感兴趣的可以自行挖掘新工具的用法。</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                链接 1：<br />
                链接 2：<br />
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="http://rootkiter.com/atom.xml"> RSS 源 </a><br />
                <a href="http://rootkiter.com/EarthWorm"> EarthWorm 主页</a><br />
              </p>
            </div>
          </div>
<!--
        <a href="/friend_links.html" style="float:right">友链在此，想看就看</a>
-->
        </div>
    </body>
</html>
