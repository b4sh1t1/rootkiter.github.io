<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>OpenSSL中的对称算法（四）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "http://hm.baidu.com/hm.js?23ca870ecf6126f172d4f8539b0a593a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">RootKiter</a></h1>
          </div>

          <h2>OpenSSL中的对称算法（四）
</h2>
<!--
<audio controls=true autoplay="true">
  <source src="http://rootkiter.rootkiter.com/music/">
</audio>
-->

<p class="meta">12 Sep 2015</p>

<div class="post">
<h2>前言</h2>

<p>最近在读OpenSSL的命令参数，在这个学习过程中发现OpenSSL之中，架构了一个非常庞大的理论系统，结果原以为学习一两天就能学完的基础知识，却学了将近一个月，才学到一些皮毛。  </p>

<p>之前整理了一些OpenSSL相关的学习笔记，这篇将涉及一些OpenSSL中对称算法的一些知识。</p>

<h2>常见的对称算法</h2>

<p>在OpenSSL中提供了多种对称算法（其中多数都为分组加密算法），以供用户使用，常用的对称算法有以下几种： </p>

<ol>
<li>AES算法：在OpenSSL中提供了AES的多种位数支持，常见的有128位，192位，256位。<br></li>
<li>Blowfish算法：OpenSSL提供了bf指令，以支持Blowfish算法的各种加解密操作。<br></li>
<li>CAST5算法：OpenSSL提供了cast指令，以支持CAST5算法的各种加解密操作。<br></li>
<li>DES算法：OpenSSL提供了des指令，以支持DES算法的各种加解密操作。<br></li>
<li>IDEA算法：IDEA是一种国际数据加密算法，由DES算法演化而来，目的是为解决DES算法密<br></li>
<li>钥太短的缺点，其算法密钥为128位长度。<br></li>
<li>RC2算法：也是一种分组加密算法，可作为DES算法的替代算法，输入输出均为64位。<br></li>
<li>RC4算法：这是一种老旧的验证和加密算法，易于受到黑客攻击。<br></li>
<li>RC5算法：这是一种相对较新的算法。<br></li>
</ol>

<h2>常用分组加密模式</h2>

<p>由于分组加密算法的输入输出均有位数限制，导致无法加密较大的数据，所以日常使用中，会将被加密文件按照算法特性进行分组，每组加密后再拼接在一起形成最终密文。按照分组后的处理方式，将分组算法进行了模式分类，在OpenSSL中有4种常见的分组加密模式，复用于分组加密算法中。以本节介绍中，所有示意图均选自《密码学》，这些图实在太难画了，就用手机照下来的，看不清也凑合看把。。。</p>

<h3>ECB</h3>

<p>电子密码本模式（Electronic Codebook Mode）。将被加密数据分段，最后一段不足时按照预定模式（补0或补F）补足。将每一段进行加密，加密后的各个段之间互不影响，将各段按顺序连在一起就是加密结果。每一段参与计算的只有&quot;密钥K&quot;，示意图如下所示：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/1.png" alt="rootkiter.com"> </p>

<h3>CBC</h3>

<p>密文块链接模式（Cipher Block Chaining Mode）。将被加密数据分段，每一段数据先与前一段数据加密后的密文进行按位模加（XOR：异或），如果当前段为首段数据（即不存在前一段数据）则与初始化向量（iv）进行模加。模加结果同&quot;密钥K&quot;共同进行加密计算得到当前段的密文。每一段参与计算的都有&quot;密钥K&quot;以及&quot;前一段密文/初始化向量&quot;。示意图如下所示：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/2.png" alt="rootkiter.com"> </p>

<h3>CFB</h3>

<p>密文反馈模式（Cipher Feedback Mode）。将被加密数据分块（r比特一块），将每一块的加密结果作为下一块的初始化向量IV，将该向量先同 密钥K 做加密计算，计算结果同与下一块的明文进行按位模加（XOR：异或），从而得到当前块的加密结果。下图是一张示意图：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/3.png" alt="rootkiter.com"> </p>

<h3>OFB</h3>

<p>输出反馈模式（Output Feedback Mode）。将被加密数据分块（r比特一块），每一块明文只同向量表的左侧r位进行按位模加（XOR：异或）得到密文。每一块密文不对后续计算造成影响，“密钥K”仅对向量表变形发生作用。这也是OFB模式 相对 CFB模式的区别。下图是一张示意图：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/4.png" alt="rootkiter.com"> </p>

<h3>EDE</h3>

<p>三重分组加密模式（Encrypt-Decrypt-Encrypt）。将一段数据通过 “加密-解密-加密” 进而生成密文。且这种模式所需密钥可以不止一个（二个不同密钥或三个不同密钥），以提高加密强度。常见的两种加密公式如下:
其中,E( k,P ) 代表: 用密钥 k 对 P 进行加密操作。D( k,C ) 代表: 用密钥 k 对 C 进行解密操作。</p>

<blockquote>
<p>二密钥加解密公式如下----可以看到 1/3 密钥是相同的：</p>

<blockquote>
<p>C = E( k1,D( k2,E( k1,P )))<br>
   P = D( k1,E( k2,D( k1,C )))</p>
</blockquote>

<p>三密钥加解密公式如下----可以看到3个密钥 各不相同：</p>

<blockquote>
<p>C = E( k3,D( k2,E( k1,P )))<br>
   P = D( k1,E( k2,D( k3,C )))</p>
</blockquote>
</blockquote>

<h2>参数指令体系（对称算法相关）</h2>

<p>OpenSSL支持8种对称加密算法，将这8中对称加密算法同5种加密模式进行糅合，最终形成了OpenSSL中强大的对称加密算法被选选项，下面在命令行下，看一下enc这条指令下支持多少种加密方法，如下图所示：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/5.png" alt="rootkiter.com"> </p>

<h3>从DES加密开始</h3>

<p>在OpenSSL中，所有的对称加密指令的格式均是想通的，掌握其中一种即可掌握其他种类的对称加密算法指令，下面先以DES指令作为入门指令，进行介绍。<br>
首先新建一个文件名为beenc.txt 内容为Hello World：<br>
<cmd>
rootkiter@PC:~$ echo &quot;Hello World&quot; &gt; beenc.txt
</cmd></p>

<p>随后用DES对该文件进行加密（密码为1234）：<br>
<cmd>
rootkiter@PC:~$ openssl des -e -in beenc.txt -out bedec  -pass pass:1234 
</cmd></p>

<p>加密后使用常用的文件查看指令进行查看可以得到密文的一些特征：</p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/6.png" alt="rootkiter.com"> </p>

<p>从cat结果可以看出，加密后的文件，不是可视字符，且以Salted作为文件开头，这意味着密文是加盐的加密结果。而在我们执行的命令中，没有加盐参数，这也表明，加盐操作是默认的。
解密操作是加密的逆操作，在des指令中有另一个名为d的参数设置，由于加密时密码为1234，所以解密时密码同样为1234，指令格式如下所示：<br>
<cmd>
$ openssl des -d -in bedec -out final.txt -pass pass:1234
</cmd></p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/7.png" alt="rootkiter.com"></p>

<p>可以看到在解密指令中同样没有提到盐值，这证明盐值对于加解密操作是透明的。那么盐值在哪里呢，通过在指令中添加-p参数可以获得加密时的盐值结果：<br>
<cmd>
$ openssl des -e -in beenc.txt -out bedec -pass pass:1234 -p
</cmd></p>

<p><img src="http://rootkiter.com/images/2015_09_12_00_23/8.png" alt="rootkiter.com"></p>

<p>从上图可以发现，盐值其实是保存在密文的8-16字节的。这也证明，盐值并不是一个需要保密的值。为什么会这样呢，这是盐值本身的特性决定的。盐值是一个随机数，他会对每次加密后的结果产生影响，导致相同密文下每两次加密产生的密文均不同，这可以在一定程度下对抗彩虹表的分析。   </p>

<p>在-p参数下，和盐值被共同输出的两个内容为 key 和 iv，这两个参数的功能又什么呢？</p>

<p>在“分组加密模式”章节中可以发现，很多模式均有“初始化密钥”和“初始化向量”，这两个值与之是相对应的。当我们通过-pass 参数来输入密码时，OpenSSL会将“密码”和“系统随机数”进行一些操作，并从操作结果中提取出“盐值”、“初始化密钥”和“初始化向量”用于后续的加密。这样就让对称算法的密码输入变得简单起来了。</p>

<p>事实上当我们不想主动输入密码时，也可以通过人为指定Key/iv/salt三个参数的值，实现加密，指令格式如下所示：<br>
<cmd>
$ openssl [被选算法名] -e -in beenc.txt -out bedec -S 0x1234 -K AAAAAAAAAAAAAAAA -iv BBBBBBBBBBBBBBBB -p
</cmd></p>

<p>不过需要注意的是，具体指定的参数是否生效还要看所选择的“分组加密模式”是否支持对应参数。比如初始向量在“电子密码本（ECB）”模式下就没有用到，此时虽然指定了-K和 -iv 的值，但是由于没有使用，同样不会有效果。</p>

<h3>指令格式讲解</h3>

<h4>基本指令格式</h4>

<p>在OpenSSL中提供两种交互模式，一种为脚本交互，一种为控制台交互。两种方式的执行效果完全相同只是交互方式略有区别，下面是两种交互模式的样例，它们是完全等价的：<br>
<em>脚本交互</em><br>
<cmd></p>

<blockquote>
<p>$ openssl des -e -in beenc.txt -out bedec  -pass pass:1234
</cmd></p>
</blockquote>

<p><em>控制台交互</em><br>
<cmd></p>

<blockquote>
<p>$ openssl<br>
OpenSSL&gt; des -e -in beenc.txt -out bedec -pass pass:1234
</cmd></p>
</blockquote>

<p>两者的唯一区别在于：脚本交互方式可以由shell脚本直接调用，而人工操作时，控制台交互模式可以在每一次指令测试时少输入一个openssl程序名。</p>

<h4>输入输出说明</h4>

<p>OpenSSL的输入输出参数种类很多，下面分别介绍。  </p>

<ol>
<li>直接由参数指定输入，比如-K/-iv 这种，再配置命令参数时直接输入即可。</li>
<li>从文件输入输出，比如in/out 这两个参数，就可以用来控制程序的输入输出路径。</li>
<li><p>控制台交互输入，在调用指令时由于没有指定输入密码，以及初始密钥等参数，指令就会在执行过程中提示用户输入口令，如下图所示：<br>
<img src="http://rootkiter.com/images/2015_09_12_00_23/9.png" alt="rootkiter.com"> </p></li>
<li><p>编码后输出，有时我们希望out选项输出的文件为可读字符内容，即可用cat直接查看的结果，这时就要用到-base64/a 选项，下图是个示例：<br>
<img src="http://rootkiter.com/images/2015_09_12_00_23/10.png" alt="rootkiter.com"> </p></li>
<li><p>pass选项可以支持5中密码输入方式，他们分别为：</p></li>
</ol>

<table><thead>
<tr>
<th style="text-align: left">支持的方式</th>
<th style="text-align: left">含义</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">-pass stdin</td>
<td style="text-align: left">从控制台读入密码</td>
</tr>
<tr>
<td style="text-align: left">-pass pass:xxxx</td>
<td style="text-align: left">从参数中读入密码密码为xxxx字段的内容</td>
</tr>
<tr>
<td style="text-align: left">-pass env:passwdvar</td>
<td style="text-align: left">从环境变量中读取密码</td>
</tr>
<tr>
<td style="text-align: left">-pass file:filename</td>
<td style="text-align: left">从文件中读入密码</td>
</tr>
<tr>
<td style="text-align: left">-pass fd:number</td>
<td style="text-align: left">number是一个文件描述句柄的编号，比如Unix系统中的管道就可以通过这种方式作为命令的输入。</td>
</tr>
</tbody></table>

<h4>外部加密库的支持</h4>

<p>现实使用中，总有人需要外接加密设备（加密机、Ukey等）或软件加密库，为了支持这些设备的加解密模块，OpenSSL提供了engine参数，该参数以设备名称（一般是一个字符串）为输入。如果不知道自己的设备名称可以先通过 engine 的-t参数进行查询。</p>

<h2>总结</h2>

<p>这篇学习笔记记录了OpenSSL中和对称算法相关的一些操作指令，以及背景知识。</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                链接 1：<br />
                链接 2：<br />
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="http://rootkiter.com/atom.xml"> RSS 源 </a><br />
                <a href="http://rootkiter.com/EarthWorm"> EarthWorm 主页</a><br />
              </p>
            </div>
          </div>
<!--
        <a href="/friend_links.html" style="float:right">友链在此，想看就看</a>
-->
        </div>
    </body>
</html>
